<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Welcome to SPHIA" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome to SPHIA">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Welcome to SPHIA">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome to SPHIA">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Welcome to SPHIA </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Welcome to SPHIA</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/08/06/kotlin-channel-actor/" itemprop="url">
                  Kotlin Channel与Actor模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-08-06T20:38:33+08:00" content="2019-08-06">
              2019-08-06
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/30/kotlin-channel-micro-batch/" itemprop="url">
                  Kotlin Channel与Micro-batch
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-30T21:48:23+08:00" content="2019-07-30">
              2019-07-30
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="手动打造batch-buffer"><a href="#手动打造batch-buffer" class="headerlink" title="手动打造batch buffer"></a>手动打造batch buffer</h2><p>除了<code>Channel</code>自身的buffer空间外，很多时候我们还需要将一条条生产出的流式数据组合成较大的批量数据。在反应式编程中，我们只需要调用<code>buffer()</code>就可以很容易地将数据进行micro-batch处理。而在使用<code>Channel</code>时，我们也可以很轻松地实现类似的缓冲功能。话不多说，直接看代码</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:kotlin %&#125;</span><br><span class="line"><span class="label">val</span> channel = Channel&lt;<span class="preprocessor">Data</span>&gt;(<span class="number">20</span>)</span><br><span class="line"><span class="label">val</span> <span class="keyword">batchChannel </span>= Channel&lt;List&lt;<span class="preprocessor">Data</span>&gt;&gt;(<span class="number">5</span>)</span><br><span class="line"><span class="label">coroutineScope</span> &#123;</span><br><span class="line">    async &#123;</span><br><span class="line">        // 创建一个大小为<span class="number">100</span>的<span class="keyword">buffer</span><br><span class="line"></span>        var <span class="keyword">buffer </span>= ArrayList&lt;<span class="preprocessor">Data</span>&gt;(<span class="number">100</span>)</span><br><span class="line">       </span><br><span class="line">        for (msg in channel) &#123;</span><br><span class="line">            <span class="keyword">buffer.add(msg)</span><br><span class="line"></span>            // 在协程上下文中，无需考虑复杂的同步问题</span><br><span class="line">            <span class="preprocessor">if</span>(<span class="keyword">buffer.size&gt;=100)&#123;</span><br><span class="line"></span>                // <span class="keyword">buffer满，发送给接收batch数据的channel</span><br><span class="line"></span>                <span class="keyword">batchChannel.send(buffer)</span><br><span class="line"></span>                // 替换新的<span class="keyword">buffer</span><br><span class="line"></span>                <span class="keyword">buffer </span>= ArrayList(<span class="number">100</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 上游channel关闭后，退出循环，但一定要记得处理剩下<span class="keyword">buffer中的数据</span><br><span class="line"></span>        <span class="preprocessor">if</span> (<span class="keyword">buffer.isNotEmpty())&#123;</span><br><span class="line"></span>            <span class="keyword">batchChannel.send(buffer)</span><br><span class="line"></span>        &#125;</span><br><span class="line">        // 全部数据处理完毕后，关掉本channel</span><br><span class="line">        <span class="keyword">batchChannel.close()</span><br><span class="line"></span>    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<p>上面多个<code>Channel</code>协作的方式，在协程编程中非常常见，即Pipeline模式。通过多个<code>Channel</code>级联形成Pipeline，可以打造更为复杂的生产消费系统，同时各个部分的职责也更加解耦。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/30/kotlin-channel-backpressure/" itemprop="url">
                  Kotlin Channel与Backpressure
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-30T20:33:59+08:00" content="2019-07-30">
              2019-07-30
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上次一次我们谈了使用<code>Channel</code>实现生产者-消费者模式的方法及其优点。今天我们来看看，怎么利用<code>Channel</code>去实现反应是编程中常常提到的<strong>Backpressure</strong></p>
<h2 id="实现Backpressure"><a href="#实现Backpressure" class="headerlink" title="实现Backpressure"></a>实现Backpressure</h2><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:kotlin %&#125;</span><br><span class="line">val channel = Channel&lt;Data&gt;(<span class="number">20</span>)</span><br><span class="line">coroutineScope &#123;</span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            val data = awaitProduce()</span><br><span class="line">            channel.send(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(<span class="number">5</span>)&#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            for (msg in channel) &#123;</span><br><span class="line">                awaitConsume(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，可以注意到，生产者和消费者外面的<code>repeat</code>中，刻意使用了不同的数字。此外，在一开始创建<code>Channel</code>时，同样指定了一个数字。这三个不同的数字，就是实现反应式编程中<strong>Backpressure</strong>的关键。</p>
<p>在创建<code>Channel</code>时，我们可以提供一个数字，作为<code>Channel</code>的<code>capacity</code>，这个数字的默认值是0.当<code>Channel</code>大小为0时，其功能就是提供并发编程中的<strong>交会点</strong>，类似Java阻塞编程中的<code>SynchronousQueue</code>，给生产者和消费者协程一个交会的场所，二者都必须等待数据被生产或取出才能继续。显然，这种情况下，一旦生产者或消费者失速，系统就会进入停滞状态。要想达到更大的吞吐量，我们需要给<code>Channel</code>提供一个缓冲长度，这样就可以减少无谓的等待时间。而这个长度同样需要精心设计，</p>
<ul>
<li>过短时，和交会点一样，双方协程频繁挂起，整体吞吐量较差，资源闲置</li>
<li>过长时，生产消费其中一方失速或过快后，容易引起系统频繁FGC、高负载或远程数据库高负载，进而导致系统大幅减速。</li>
</ul>
<p>而生产者和消费者协程的数量，同样需要慎重考虑。在<code>Channel</code>本身充分长的情况下，生产者协程过多，就会引起生产者的超速，而消费者协程过多，则会引起消费者的超速，两种情况下同样会导致系统高负载。</p>
<h2 id="参数调节经验"><a href="#参数调节经验" class="headerlink" title="参数调节经验"></a>参数调节经验</h2><p>那么，在实际线上生产时，究竟该怎么调整这些参数呢？</p>
<h3 id="Channel的缓冲大小"><a href="#Channel的缓冲大小" class="headerlink" title="Channel的缓冲大小"></a><code>Channel</code>的缓冲大小</h3><p>这一参数的本质作用，是为了给生产者和消费者之间的速度差提供缓冲。在设置参数时，我们主要考虑几个问题</p>
<ol>
<li>生产消费的速度差。当预计生产者-消费者的速度差越大或越不稳定的情况下，<code>Channel</code>的值就应该越大一些，以提供更多的缓冲。如果有信心使二者速度平稳一致（很难做到），就可以设置很小的缓冲值。</li>
<li>单条数据的大小和JVM的内存情况。如果单条数据的体量非常小（如一个int），那么即使设置较大的缓冲，往往也无可厚非。但是当单条数据的体量非常大时（如包含数千条数据的一个bundle），就需要重点考虑缓冲大小，以避免引发Full GC甚至是OOM.</li>
<li>一方失速可能引起的后果。这一条最容易被忽视掉，即使我们的内存空间足够大，可以缓冲无限长的数据在<code>Channel</code>中，也不能高枕无忧。举个例子，消费者协程因远程数据库原因突然失速，<code>Channel</code>中就会马上积累起极大量的数据，而当远程恢复正常后，消费者协程就会源源不断地从<code>Channel</code>中取出数据，非常容易引起系统的高负载。而如果<code>Channel</code>缓冲较小的话，即时发生上面的问题，也完全不会引发高负载的问题。当然，是以较低的吞吐量为代价。简单地讲，可以讲<code>Channel</code>比作一个水库，开闸放水时，水量越大，就越容易冲垮下游。</li>
</ol>
<p>因此，设置<code>Channel</code>的缓冲时，总体上还是应该控制其大小，不宜过大。在系统性能（内存及负载）可承受的情况下，适当增加缓冲大小。当缓冲大小有限时，<code>Channel</code>才能最好地发挥出backpressure的作用：消费者降速后，通过<code>Channel</code>挂起生产者协程；消费者提速后，生产者也随着恢复速度。</p>
<h3 id="生产者协程的数量"><a href="#生产者协程的数量" class="headerlink" title="生产者协程的数量"></a>生产者协程的数量</h3><p>设置相对较小的<code>Channel</code>后，为了避免系统吞吐量的损失，我们可以增加生产者协程的数量。生产者处在这个生产消费系统的上游，也是应用内backpressure的终点。因此，生产者可以很好地利用backpressure的功能。我们可以放心地设置较多的生产者协程，因为在任何情况下，backpressure都会自动调节生产者的速度。</p>
<ul>
<li>消费者较慢时，<code>Channel</code>接近满负荷运作，多数生产者挂起，系统整体速率被稳定控制住。而且协程的挂起几乎没有性能损耗。</li>
<li>消费者较快时，大量的生产者可以充分发挥出生产速度，提升整个系统的吞吐量。</li>
</ul>
<h3 id="消费者协程的数量"><a href="#消费者协程的数量" class="headerlink" title="消费者协程的数量"></a>消费者协程的数量</h3><p>我们已经有了稍小的<code>Channel</code>加上较多的生产者协程，那么如何设置消费者协程的数量呢？做了上面的设置后，此时消费者协程的数量几乎决定了整个系统的吞吐量。我们只需要考虑系统和远程数据库的的负载承受能力即可。当生产消费的数据较繁重、负载较高时，可以将消费者协程的数量设置得小一些；反之，则适当增大。</p>
<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ol>
<li><code>Channel</code>缓冲设置偏小一些，但不要太小</li>
<li>生产者协程数量可以较多一些</li>
<li>消费者协程数量决定整体吞吐量，视系统负载情况而定</li>
</ol>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/25/elasticsearch-time-indices-4/" itemprop="url">
                  用时间滚动索引优化ES读写速度（四）再谈shard数量设置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-25T22:03:12+08:00" content="2019-07-25">
              2019-07-25
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>unwieldy</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/25/elasticsearch-time-indices-3/" itemprop="url">
                  用时间滚动索引优化ES读写速度（三）冷索引优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-25T21:36:49+08:00" content="2019-07-25">
              2019-07-25
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>上一篇我们讲了用冷热分离、读写分离、时间滚动的方案动态构建索引。这一篇，主要来简单补全一下，要实现所需要的ES机制。</p>
<h2 id="索引模板"><a href="#索引模板" class="headerlink" title="索引模板"></a>索引模板</h2><p>每一天，我们都需要不断创建新的热索引和冷索引，因此用索引模板统一索引设置很重要了。这里就不放代码了，简单写一下设置方式</p>
<ul>
<li>热索引：shard数量较多，replica适量，所在节点需要RAM较少</li>
<li>冷索引：shard数量较少，replica开始设置为0，所在节点需要RAM较大</li>
</ul>
<h2 id="索引别名"><a href="#索引别名" class="headerlink" title="索引别名"></a>索引别名</h2><p>因为我们的索引是不断动态创建、迁移和销毁的，因此，需要在索引名前面再增加一层抽象，以减少应用读写索引时的复杂度。应用仅仅需要指向索引别名，不需要关心背后操作的是具体的哪个索引或者哪些索引。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">别名：active-<span class="typedef"><span class="keyword">data</span></span></span><br><span class="line">背后的索引：active-<span class="typedef"><span class="keyword">data</span>-2019.07.25（每天变化）</span></span><br><span class="line"></span><br><span class="line">别名：search-<span class="typedef"><span class="keyword">data</span></span></span><br><span class="line">背后的索引：active-<span class="typedef"><span class="keyword">data</span>-2019.07.25（每天变化）加上所有的inactive-<span class="keyword">data</span>-2019.xx.xx</span></span><br></pre></td></tr></table></figure></p>
<p>这样，写入时，应用就会一直指向最新的索引，而搜索时，应用会指向所有active或inactive的索引，当然，也可以实现更加精细的控制，任由开发人员想象。</p>
          <div class="post-more-link text-center">
            <a class="btn" href="/2019/07/25/elasticsearch-time-indices-3/#more" rel="contents">
              Read more &raquo;
            </a>
          </div>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/25/elasticsearch-time-indices-2/" itemprop="url">
                  用时间滚动索引优化ES读写速度（二）滚动索引构成
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-25T21:02:03+08:00" content="2019-07-25">
              2019-07-25
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章讲了ES数据量增大后，优化搜索和写入性能的方案，简单回顾下就是</p>
<ol>
<li>要提升写入速度，需要将数据尽可能分布到多个节点的多个shard上，每个shard保持较小的体量。</li>
<li>要提升搜索速度，需要尽量减少shard的数量，以更好地利用缓存，减少分布式搜索过程中的性能损耗。</li>
</ol>
<p>有意思的是，上面的两条方案竟然是完全相反的。提升了写入速度，shard就会变多，搜索损耗就会增大。而提升了搜索性能，shard就会减少，数据更加集中，写入速度就会减慢。那么两者是否可以兼得，答案是可以的，就是利用时间滚动索引的方案。</p>
<h2 id="时间滚动索引"><a href="#时间滚动索引" class="headerlink" title="时间滚动索引"></a>时间滚动索引</h2><p>既然ES读写优化上存在天然的矛盾，我们自然而然需要对读写操作分离，也就是我们常讲的读写分离。而这种append-only的数据模式下，新写入的数据我们可以称作活跃数据或者热数据，旧数据则可以称作非活跃数据或冷数据。新数据既要写入也要能够被搜索，而旧数据只需要被搜索，不会被搜索。我们可以利用这一点，将冷热数据进行分离。</p>
<p>首先考虑不断新写入的数据，这些数据需要一个较小的索引以保持写入速度，而当索引大小超过一定量或者索引存活超过一定时间后，就需要更换新的索引写入。简便起见，我们接下来就统一用一天的时间作为索引的寿命。那么，今天的写入索引就可以叫做<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">active-data-<span class="number">2019.07</span><span class="number">.25</span></span><br></pre></td></tr></table></figure></p>
<p>如上文所说，这一索引需要较多的shard数目以提升写入速度，因此假设我们有8个数据节点，我们可以设置<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"number_of_shards"</span>:<span class="number">16</span></span><br></pre></td></tr></table></figure></p>
<p>因为该节点也需要参与搜索，因此可以适当的设置shard数目，具体的最优数值还是需要大量的测试才能得出结论。</p>
<p>而在今天过去之后，我们就需要创建新的索引来容纳写入数据，以避免写入速度因数据量过大而降低<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">active-data-<span class="number">2019.07</span><span class="number">.26</span></span><br></pre></td></tr></table></figure></p>
<p>索引设置还是和上一个索引一样。</p>
<p>而已经不再写入的旧索引，我们就只需要对索引进行针对搜索性能的优化。优化的方案有很多种，这里就介绍ES官方推荐的一种，即</p>
<ol>
<li>设置索引为只读</li>
<li>将索引所有shard移动到一个节点上</li>
<li>合并所有shard到一个大的shard中，创建新的冷数据索引</li>
<li>执行force merge操作合并所有segment</li>
<li>删除旧的热索引</li>
</ol>
<p>这样我们就得到了一个新的索引<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.25</span></span><br></pre></td></tr></table></figure></p>
<p>这个索引只有一个primary shard，shard内部只有一个segment，并且拒绝任何写入，最大程度地减少了搜索的损耗。</p>
<p>这样，随着时间的进行，我们就得到了一系列的索引<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">active-data-<span class="number">2019.08</span><span class="number">.02</span></span><br><span class="line">inactive-data-<span class="number">2019.08</span><span class="number">.01</span></span><br><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.31</span></span><br><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.30</span></span><br><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.29</span></span><br><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.28</span></span><br><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.27</span></span><br><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.26</span></span><br><span class="line">inactive-data-<span class="number">2019.07</span><span class="number">.25</span></span><br></pre></td></tr></table></figure></p>
<p>利用时间索引的特性，我们还可以很方便地实现数据窗口的功能。即如果只需要保存一定时间的数据，就可以简单地删掉之前时间的索引。ES中删除整个索引的性能要远远超过按搜索条件删除。</p>
<p>基本的方案搞清楚了，那么上面这些复杂的操作，怎么执行和实现呢，我们还需要几个ES提供的武器：索引模板、索引别名、rollover API、shrink等等等，下篇再看。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/25/elasticsearch-forcemerge/" itemprop="url">
                  elasticsearch-forcemerge
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-25T20:17:34+08:00" content="2019-07-25">
              2019-07-25
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/23/kotlin-channel/" itemprop="url">
                  Kotlin Channel与生产者-消费者模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-23T20:29:51+08:00" content="2019-07-23">
              2019-07-23
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>自从实验版本发布之后，Kotlin协程就受到了广泛的关注和应用。顺序编写，异步执行，这一特性就足以令Kotlin协程战胜众多并发编程的候选方案了。然而，并发编程并不仅仅是让代码异步执行这么简单。在异步之外，还需要考虑很多因素。下面我们就从最常见的生产者-消费者模式谈起。</p>
<h2 id="生产者-消费者模式"><a href="#生产者-消费者模式" class="headerlink" title="生产者-消费者模式"></a>生产者-消费者模式</h2><p>传统Java中的生产者-消费者模式很简单，一个或多个生产者线程，一个公用的阻塞队列（往往有ArrayBlockingQueue和LinkedBlockingQueue两种选择），以及一个或多个消费者线程。生产者源源不断地将数据入队到阻塞队列中，消费者则循环从队列中取出元素进行消费。这样看似简单的设计，在实际生产环境的应用中，往往会出现大量的问题。</p>
<p>我们就以从迁移数据的场景为例子。我们的生产者需要从远程数据源A中源源不断地拉取数据，而消费者负责将数据写入迁移后的远程数据存储B，并且在写入之前，可能需要对数据进行一定的重构以适应新数据存储。这一系列过程中，实际上有多个不同的环节，会影响整体的工作速度：</p>
<ol>
<li>远程数据源A处理拉取数据请求的速度</li>
<li>生产者从远程数据源A中拉取数据的速度</li>
<li>生产者将数据放入队列的速度</li>
<li>消费者取出数据的速度</li>
<li>消费者对数据进行业务处理的速度</li>
<li>消费者将数据写入远程数据存储B的速度</li>
<li>远程数据存储B接纳新写入数据的速度</li>
</ol>
<p>首先我们假设一切顺利，生产者拉取数据的速度非常快，而阻塞队列的长度无限，消费者写入的速度也非常快，两端数据源处理性能也足够强，这种情况下，是不是就可以高枕无忧了呢？答案是错的，当整个流程的速度增长过快且不受限制时，很大几率会导致机器本身的性能出现问题，成为新的瓶颈。生产者拉取数据、内部对数据的处理、消费者写入数据，甚至加上日志的大量，这些操作如果不受限制，将会带来大量的IO开销+CPU开销，即使不考虑内存的问题，CPU和磁盘一样很容易被打满并导致Load飙高。而Load过高往往会引起TCP重传，这时整个系统的性能就会急剧恶化。消费者将是最先受到影响的，数据远程写入的速度将大幅降低，引起队列中数据堆积，进而引发Full GC，进一步恶化性能，甚至最终导致OOM崩溃。</p>
<p>如果消费者的消费速度过慢（IO速度慢），而消费者线程又太少，这时就一定会引起上游的问题。如果我们使用的是无限长的阻塞队列，生产的消息会不停往队列中堆积。而应用自身的内存空间是有限的，因此最终必定会引起整个JVM的OOM。而如果使用有限长的阻塞队列，那么当消费者过慢时，就会频繁触发队列的拒绝策略，如抛异常、拒绝入队、阻塞生产者线程、超时后丢弃等等等等。不同的代码编写和API调用，会有不同的拒绝策略。而这些拒绝策略都会带来问题，要么使得上游线程池阻塞并耗尽，要么使得队列被耗尽或引发OOM。那么，有没有更好的解决方式呢？</p>
<p>而当消费者速度过快，生产者过慢时。队列长时间为空，引起消费者全部阻塞，也会平白无故地浪费线程资源。</p>
<h2 id="Kotlin-Channel"><a href="#Kotlin-Channel" class="headerlink" title="Kotlin Channel"></a>Kotlin Channel</h2><p>Kotlin中的<code>Channel</code>与Java的<code>BlockingQueue</code>看起来很相似，最大的不同是，阻塞队列中的入队和出队方法全部是阻塞的，当队满时和队空时，相应线程会阻塞；而在<code>Channel</code>中，<code>send</code>和<code>receive</code>方法是<code>suspend</code>的，并不阻塞。那么和<code>BlockingQueue</code>相比，<code>Channel</code>究竟好在哪里呢？</p>
<h3 id="挂起协程而非阻塞线程"><a href="#挂起协程而非阻塞线程" class="headerlink" title="挂起协程而非阻塞线程"></a>挂起协程而非阻塞线程</h3><p>在<code>Channel</code>中，<code>send</code>和<code>receive</code>方法都是<code>suspend</code>方法。这意味着，在需要向满了的队列中放入元素或从空队列中取出元素时，负责任务的协程将会挂起，等待条件恢复执行。我们知道，协程的本质是回调，是非常轻量级的，因此协程挂起时并不会消耗资源。而在使用阻塞队列时，当<code>put</code>和<code>take</code>函数发生阻塞，或者处理生产者或消费者线程自己发生阻塞时，整个线程会被阻塞，这就带来了一个难以解决的矛盾：要提升整个系统的处理速度，必须增加生产者和消费者线程的数目；而线程数目越多，发生阻塞的可能性就越大，大量的线程资源会被浪费在阻塞状态下。这种状况下，各个部分线程数目的调优就非常重要，但不幸的是，这种调优的难度也是非常大的，往往非常依赖经验，而无法准确判断。当然，在Java中也可以使用多路复用、Reactor等方式，去减少这种阻塞对性能的影响，但开发过程会相对复杂一些，也更容易出错。</p>
<p>除此之外，使用挂起API，可以享受整个Kotlin协程下的红利，无论是开发速度、代码简洁度，还是程序的运行速度，都会受益。</p>
<h3 id="可关闭"><a href="#可关闭" class="headerlink" title="可关闭"></a>可关闭</h3><p><code>Channel</code>相较阻塞队列还有一点很方便的好处，即<code>Channel</code>是可以主动关闭的。在使用阻塞队列时，所有生产者完成全部生产工作后，要想准确地通知消费者，多数情况下都要使用共享内存变量的方式，让消费者主动去轮询，进而结束消费。而对那些不幸停留在阻塞状态的消费者线程而言，还需要用中断或者取消的机制去强制结束阻塞。这一系列操作看起来不重要，开发起来总会遇到各种各样的corner case。可以说，如果真的想开发一个完全无懈可击的取消机制，还是存在一定难度和复杂度的。</p>
<p>也有一种方式，是使用特殊的<em>end of stream</em>标志对象，以通知消费者消费结束。且不提这种方法稍显麻烦，单个的特殊对象也只能通知一个消费者线程，只能在多路复用的场景下发挥作用。</p>
<p>而使用<code>Channel</code>时这个问题甚至不再是一个问题。因为<code>Channel</code>提供了<code>close()</code>方法，用户可以显式地调用关闭函数。调用关闭后，<code>Channel</code>的<code>Iterator</code>会配合关闭状态，适时地结束消费循环。如下面简单的代码就可以展示：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">coroutineScope &#123;</span><br><span class="line">    <span class="command">launch</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (msg <span class="keyword">in</span> channel) &#123;</span><br><span class="line">            awaitConsume(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生产者调用<code>channel.close()</code>之后，消费者的for循环，可以自动等到<code>channel</code>中的所有对象被取出后，结束循环，完全无需额外的工作去手动结束消费。这也符合了并发编程中的一个很有名的原则</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<h3 id="Fan-in和Fan-out"><a href="#Fan-in和Fan-out" class="headerlink" title="Fan-in和Fan-out"></a>Fan-in和Fan-out</h3><p>在前面讨论阻塞队列时，我们说到，阻塞队列很难控制生产者线程和消费者线程的数量，线程过少时，整体性能不能充分发挥；线程过多时，因为线程太重量级以及频繁的阻塞，会引入不少的性能损耗。而在使用协程时，我们同样需要去考虑协程数量的问题。</p>
<p>所幸，使用协程时，调整协程数量非常的轻松而且直观。我们只需要将上面代码中的for循环，多重复几分，就可以生成多个消费者协程，也就是所谓的<em>Fan-out</em>.<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:kotlin %&#125;</span><br><span class="line">coroutineScope &#123;</span><br><span class="line">    repeat(<span class="number">5</span>)&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            for (msg in channel) &#123;</span><br><span class="line">                awaitConsume(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样，在生产者一侧，也可以用同样的方式去调整生产者数量，即<em>Fan-in</em>.<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:kotlin %&#125;</span><br><span class="line"><span class="title">coroutineScope</span> &#123;</span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        launch &#123;</span><br><span class="line">            val <span class="typedef"><span class="keyword">data</span> = awaitProduce<span class="container">()</span></span></span><br><span class="line">            channel.send(<span class="typedef"><span class="keyword">data</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Structured-Concurrency"><a href="#Structured-Concurrency" class="headerlink" title="Structured Concurrency"></a>Structured Concurrency</h3><p>使用<code>Channel</code>实现生产者-消费者模式，还有一个非常重要的优势，那就是Kotlin引以为傲的<em>Structured Concurrency</em>。当一个系统中有大量生产者和消费者时，因为DB的原因或业务代码的原因，再或者是个别脏数据的影响，很容易导致部分生产者或消费者失败发生异常。在有些场景下，这种失败是致命的。如在迁移一些重要的用户数据、业务数据中出现无法解决的错误时，必须让中断整个迁移过程再重新开始。特别是当单个生产者或消费者出错，而其他生产者消费者正常运转时，开发者很容易误以为全部任务成功，而在不知不觉中丢掉了部分数据。</p>
<p>使用Kotlin的<em>Structured Concurrency</em>就可以轻松解决这一问题。我们只需要将所有生产者和消费者协程（不管有多少个），统统放到一个专门的<code>coroutineScope</code>中，再将上面例子中的<code>launch</code>改为<code>async</code>（为了传播异常），就可以实现：一个生产者或消费者协程抛出异常，所有生产者和消费者协程立即取消。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:kotlin %&#125;</span><br><span class="line">val channel = Channel&lt;Data&gt;(<span class="number">20</span>)</span><br><span class="line">coroutineScope &#123;</span><br><span class="line">    repeat(<span class="number">10</span>)&#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            val data = awaitProduce()</span><br><span class="line">            channel.send(data)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    repeat(<span class="number">5</span>)&#123;</span><br><span class="line">        async &#123;</span><br><span class="line">            for (msg in channel) &#123;</span><br><span class="line">                awaitConsume(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/22/elasticsearch-dao/" itemprop="url">
                  谈不同数据库的封装问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-22T21:08:12+08:00" content="2019-07-22">
              2019-07-22
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Java服务端的开发，无论是Web后台、移动后台，或者计算型应用，数据访问层（DAL）总是必不可少的。而数据访问层内部又会再次细分，以MySQL数据源为例，使用MyBatis的话，首先需要一层mapper.xml定义SQL操作，然后需要一层DAO接口提供CRUD调用，再往上往往还会有一层Manager层封装DAO的操作，提供给上层的Service调用。</p>
<blockquote>
<p>Mapper -&gt; DAO -&gt; Manager -&gt; Service -&gt; Controller</p>
</blockquote>
<p>在使用MySQL或其他类似关系型数据库时，这样的封装和分层方式虽然有时有些繁琐，但基本上已经算是比较好的做法。而当项目中引入了NoSQL或搜索引擎时，传统的数据访问层内部的分层方式，往往就不那么容易实现。大多数的NoSQL实现都没有提供如传统关系数据库般的复杂封装方式，一般情况下只是提供一个Client，加上一系列方法，供用户调用。当项目中需要大量使用NoSQL时，开发者难免会手痒，想要把NoSQL也封装成类似MyBatis或其他类似库的结构，以方便访问。然而，这种封装所带来的问题，也许会多过好处。</p>
<h2 id="正视不同数据库之间的本质区别"><a href="#正视不同数据库之间的本质区别" class="headerlink" title="正视不同数据库之间的本质区别"></a>正视不同数据库之间的本质区别</h2><p>在工作过程中，笔者曾不止一次地看到有团队或开发者，在最底层就试图将不同的数据库统一封装起来，提供相同的底层API。这么做乍一看很美好，似乎可以零成本切换底层数据源，屏蔽一切数据层的细节。然而实际上，这种最底层封装所带来的收益，即使有的话，恐怕只是一时的。</p>
<p>举一个封装MySQL和ES的例子。公司内负责ES维护和优化的团队，希望将MySQL和ES统一起来，为ES提供一套类似SQL形式的API，即支持SQL的查询语句，并提供MyBatis风格的简单CRUD API。这一想法看上去非常美好，他们也花了大量精力做出来了一个非常复杂的ES客户端library，可是很多团队在短暂地使用后，就会发现其中的种种问题。</p>
<p>不同的数据库选型之间，往往有着本质上的区别。单机VS分布式，底层数据结构，是否支持事务，是否支持索引，索引的使用形式，等等等等。强行试图封装不同的数据库，并不是不可以，但是一定要意识到，其中的复杂度，尤其是封装后组合爆炸带来的复杂度，会远远超出你的想象。</p>
<h3 id="复杂的查询语句"><a href="#复杂的查询语句" class="headerlink" title="复杂的查询语句"></a>复杂的查询语句</h3><p>继续以MySQL和ES为例，MySQL中使用SQL进行数据查询，而ES则使用JSON，二者所支持的数据查询方式差别极大。MySQL中基本的布尔操作还算简单，一旦涉及到聚合操作、JOIN操作等，其复杂度就会剧烈提升。一些复杂的SQL，即使是很有经验的程序员，也需要投入一定精力去细细优化。</p>
<p>而ES中，即使是基本的逻辑操作就与SQL有很大不同，ES中的<code>filter</code>和<code>must</code>都类似<code>AND</code>操作，但二者间又有很多细微不同，<code>should</code>初看好像对应了<code>OR</code>，但实际上其语义更加复杂，在不同上下文出现有着完全不同的作用；更有<code>mininum_should_match</code>等等诸多辅助性的参数，难以在SQL中实现。因此，虽然不同的查询语法本质上的逻辑都是等价的，但在工程上，单单是想要实现SQL和ES JSON之间的互译，已经是非常困难了，要想针对双方完全不同的存储结构进行优化，就更是难上加难。当然，网络上也有将SQL翻译成ES JSON的工具，但这样的工具用在项目重构、迁移的过程中，提供辅助作用还好，在稳定的生产代码中使用这种间接性质的翻译，就难以进行针对性的优化，很可能会导致资源的严重浪费。</p>
<h3 id="独有的功能"><a href="#独有的功能" class="headerlink" title="独有的功能"></a>独有的功能</h3><p>即使我们对查询语句的封装网开一面，单单来看其他的CRUD操作，封装的效果也是不容乐观的。以简单的一条<code>SELECT</code>为例，单机的MySQL很简单，分库分表后就需要路由，而ES中又需要考虑是否支持routing的问题。MySQL中有着复杂的事务和各种加锁功能，这些在ES上都是不可能实现的。反过来，ES的routing机制，脚本Update，天生的数组支持，refresh策略的调控，也都是MySQL所无法模拟的。</p>
<p>在这种情况下，还要封装统一的接口，就会发现一个简单的API上，需要提供的可选参数越来越多，需要支持的独特注解也越来越多，而在方法实现时，各种复杂的parsing、映射、调参也接踵而至。即使你实现了大部分的功能，这样的代码在实际工程的复杂性面前，必然是不堪一击的。很快各个使用方就会发掘出其中越来越多的bug，你也会需要越来越多的代码去处理各种复杂的corner case。笔者在使用他们的服务时，就曾经发现一个哭笑不得的错误，将ES的JSON错误解析，丢掉了其中的重要参数。</p>
<h2 id="失败的世界语"><a href="#失败的世界语" class="headerlink" title="失败的世界语"></a>失败的世界语</h2><p>在如此高的复杂度下，除非团队的实力足够强（需要PL领域的专家），人手、时间、测试资源都足够充裕，不要轻易地尝试统一抽象和封装不同的数据库。强如Pivotal做出的Spring Data，在实际使用中也会发现很多的不足。过度乐观地进行封装，忽视逻辑上不可消灭的高复杂度，最终面临的一定是痛苦而漫长的后续维护和测试。</p>
<p>这就如同当年失败的世界语一样，当你真的成功封装了不同的数据库后，你所创造的新的模型，也必将需要更多的精力去学习。而在实际的项目开发中，数据源的切换和更替大多是一次性的或往复的，很多时候并不需要复杂的抽象和封装。特别是在切换数据库之后，为了充分利用新数据库的特性，业务的建模也很可能会发生大规模的变更。业务建模变化后，底层数据层的封装就会变得毫无意义。退一步讲，即使真的需要封装，也只需在更上层（如Manager层）简单封装即可。为了一次性的成本，过多的投入前期精力，往往是得不偿失的。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/07/22/elasticsearch-time-indices/" itemprop="url">
                  用时间滚动索引优化ES读写速度（一）读写性能分析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-07-22T20:21:55+08:00" content="2019-07-22">
              2019-07-22
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="逐渐恶化的性能"><a href="#逐渐恶化的性能" class="headerlink" title="逐渐恶化的性能"></a>逐渐恶化的性能</h2><p>使用ES时，有很多场景，我们只需要插入新数据，不需要对旧数据进行更新或随机删除。最典型的场景就是日志了，只会新增新的日志，不需要对旧数据进行任何的修改。在其他场景下，只要你的数据符合append-only特征，都会有以下的共同特性：</p>
<ol>
<li>数据只新增，没有更新，可能有批量删除但是没有随机删除</li>
<li>所有数据都需要能够被搜索</li>
<li>数据带有时间戳</li>
<li>数据量往往非常大</li>
</ol>
<p>这种类型的数据，如果全部存储到一个巨大的索引中，不管是搜索性能还是插入性能，都会随着时间的增加不断恶化。在笔者所管理过的一个线上ES索引中，仅仅过了6个月，搜索RT就从20ms上涨到了120ms。在分布式开发时，我们常讲一个方案是否时scalable的，那种单一索引的方案在时间维度上，就是完全不scalable的。</p>
<p>索性，ES官方提出了一种时间滚动索引的方案，可以有效地解决该类场景下，性能逐渐恶化的问题。</p>
<h2 id="写入的优化"><a href="#写入的优化" class="headerlink" title="写入的优化"></a>写入的优化</h2><p>首先我们来看看写入的场景。ES单个shard的数据量上涨地非常高以后，插入一些新文档后，索引内部执行refresh、merge和flush的时间都将大幅上涨。因此，我们有必要控制写入索引的索引大小不要过大，这样新文档就能尽快完成写入和刷新。</p>
<p>而从shard数量上看，单个索引内的shard数量越多，插入操作的性能一般就会越好。每个插入的文档都会被route到其中一个shard上，当然shard本身的体积越小，插入就会越轻量，性能更好。特别是写入到不同节点上，各个节点互相独立，写入速度可以得到大幅提升。</p>
<p>因此，要优化写入速度，我们需要控制写入索引的大小，同时适量增大shard的数目。</p>
<h2 id="搜索的优化"><a href="#搜索的优化" class="headerlink" title="搜索的优化"></a>搜索的优化</h2><p>然后我们再来看看看搜索的场景。搜索性能的分析要比写入更加复杂一些，我们还是先从单个shard的大小上来分析。我们都知道，ES的一个shard就是lucene的一个Index，背后是由倒排索引提供支持。Lucene的倒排索引中，影响搜索速度的关键是term dictionary，其搜索时间复杂度为<code>O(logN)</code>。在对数时间复杂度下，增大总数据量，时间的增加相对较小。因此，使用较大的shard是可以接受的。</p>
<p>在非Routing搜索的情况下，大部分搜索请求，都需要询问全部节点上的全部shard，然后再对所有结果进行聚合，才能获得最终答案。同样大小的索引，如果我们多分一些shard，到多一些节点上，单个shard的搜索时间就会降低，而最后需要聚合的时间以及可能损耗在分布式集群中的时间就会增加一些。但是需要注意的是，搜索阶段的时间下降是对数的而非线性的，也就是说其下降效果并不显著。而且整个搜索阶段的时间损耗受木桶效应影响，也就是说取决于最慢的那一个shard。而且shard增多后，某个shard失败的可能性也会增加，这时就需要重试，会严重增加搜索阶段的总时间损耗。而聚合阶段的时间损耗则是必定上升的。因此，可以得出结论，平均情况下，多分出shard到不同的节点，对搜索性能的提升有限，甚至更大的可能是会引起性能下降。</p>
<p>此外，还有一个不容小觑的因素，即ES对cache的利用。当某个节点上shard过多时，cache miss就可能会增加，就会增加读取硬盘的次数。事实上，往往这个问题才是最终决定性影响ES搜索性能的关键因素。</p>
<p>总结下就是</p>
<ol>
<li>对数复杂度下，增大shard，时间恶化较少</li>
<li>多shard下，搜索阶段时间减少较少，而shard出错概率增加，木桶效应可能导致时间反而增加</li>
<li>多shard下，聚合阶段时间损耗增加</li>
<li>多shard下，对cache的利用会恶化。</li>
</ol>
<p>所以，可以得出结论，要优化搜索速度，我们需要减少索引内shard的数量。</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>思路有了，下一篇就来看一下ES官方推荐的索引构建方式。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="SphiaTower" />
          <p class="site-author-name" itemprop="name">SphiaTower</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">148</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SphiaTower</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  

  
  


</body>
</html>
