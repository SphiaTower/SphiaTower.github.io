<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Welcome to SPHIA</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-03-05T06:42:42.348Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SphiaTower</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Wear 开发 （八） 添加语音功能</title>
    <link href="http://yoursite.com/2016/03/05/wear-dev-8/"/>
    <id>http://yoursite.com/2016/03/05/wear-dev-8/</id>
    <published>2016-03-05T06:28:29.000Z</published>
    <updated>2016-03-05T06:42:42.348Z</updated>
    
    <content type="html">&lt;p&gt;Wear提供两种语音动作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统提供的：这些语音动作基于任务，并内置在Wear平台。在想要启动的activity中过滤出他们，比如“记笔记”或者“设定闹铃”。&lt;/li&gt;
&lt;li&gt;应用提供的：这些语音动作基于应用，声明他们就像启动图标一样。用户说“启动 ”来使用语音动作并启动一个指定的activity。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;声明系统提供的语音动作&quot;&gt;&lt;a href=&quot;#声明系统提供的语音动作&quot; class=&quot;headerlink&quot; title=&quot;声明系统提供的语音动作&quot;&gt;&lt;/a&gt;声明系统提供的语音动作&lt;/h1&gt;Android Wear平台提供了很多基于用户动作的语音intent。当用户说出语音动作后，应用可以过滤发出的intent来启动一个activity。如果想要启动一个后台运行的service，显示一个activity作为可见信号，然后在activity中启动service。记得在想要离开可见信号时调用&lt;code&gt;finish()&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;拿“记笔记”作为例子，声明intent filter来启动一个activity：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity android:name=&amp;quot;MyNoteActivity&amp;quot;&amp;gt;
    &amp;lt;intent-filter&amp;gt;
        &amp;lt;action android:name=&amp;quot;android.intent.action.SEND&amp;quot; /&amp;gt;
        &amp;lt;category android:name=&amp;quot;com.google.android.voicesearch.SELF_NOTE&amp;quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;声明应用提供的语音动作&quot;&gt;&lt;a href=&quot;#声明应用提供的语音动作&quot; class=&quot;headerlink&quot; title=&quot;声明应用提供的语音动作&quot;&gt;&lt;/a&gt;声明应用提供的语音动作&lt;/h1&gt;&lt;p&gt;如果这些平台语音intent不能满足要求，可以直接通过“Start Activity名”的语音动作来启动应用。&lt;/p&gt;
&lt;p&gt;注册一个“启动”动作与在手机上注册启动图标一样，只是需要一个语音动作而非图标。&lt;/p&gt;
&lt;p&gt;要指定“启动”之后要说的文字，为想要启动的activity指定一个&lt;code&gt;label&lt;/code&gt;属性。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;application&amp;gt;
  &amp;lt;activity android:name=&amp;quot;StartRunActivity&amp;quot; android:label=&amp;quot;MyRunningApp&amp;quot;&amp;gt;
      &amp;lt;intent-filter&amp;gt;
          &amp;lt;action android:name=&amp;quot;android.intent.action.MAIN&amp;quot; /&amp;gt;
          &amp;lt;category android:name=&amp;quot;android.intent.category.LAUNCHER&amp;quot; /&amp;gt;
      &amp;lt;/intent-filter&amp;gt;
  &amp;lt;/activity&amp;gt;
&amp;lt;/application&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;获取任意语音输入&quot;&gt;&lt;a href=&quot;#获取任意语音输入&quot; class=&quot;headerlink&quot; title=&quot;获取任意语音输入&quot;&gt;&lt;/a&gt;获取任意语音输入&lt;/h1&gt;&lt;p&gt;除了用语音动作启动activity之外，也可以调用系统内置的语音识别activity来获取语音输入，特别是在需要搜索或作为信息发送时。&lt;/p&gt;
&lt;p&gt;在应用中调用&lt;code&gt;startActivityForResult()&lt;/code&gt;并使用&lt;code&gt;ACTION_RECOGNIZE_SPEECH&lt;/code&gt;动作。这将启动一个语音识别activity，然后可以在&lt;code&gt;onActivityResult()&lt;/code&gt;中处理结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; SPEECH_REQUEST_CODE = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create an intent that can start the Speech Recognizer activity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;displaySpeechRecognizer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Intent intent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Start the activity, the intent will be populated with the speech text&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    startActivityForResult(intent, SPEECH_REQUEST_CODE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// This callback is invoked when the Speech Recognizer returns.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// This is where you process the intent and extract the speech text from the intent.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onActivityResult&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; requestCode, &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; resultCode,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Intent data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (requestCode == SPEECH_REQUEST_CODE &amp;amp;&amp;amp; resultCode == RESULT_OK) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;String&amp;gt; results = data.getStringArrayListExtra(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                RecognizerIntent.EXTRA_RESULTS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        String spokenText = results.get(&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Do something with spokenText&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onActivityResult(requestCode, resultCode, data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;Wear提供两种语音动作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统提供的：这些语音动作基于任务，并内置在Wear平台。在想要启动的activity中过滤出他们，比如“记笔记”或者“设定闹铃”。&lt;/li&gt;
&lt;li&gt;应用提供的：这些语音动作基于应用，声明他们就像启动图标一样。用户说“启动 ”来使用语音动作并启动一个指定的activity。
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android Wear 开发 （七） 保持应用可见</title>
    <link href="http://yoursite.com/2016/03/05/wear-dev-7/"/>
    <id>http://yoursite.com/2016/03/05/wear-dev-7/</id>
    <published>2016-03-05T03:32:23.000Z</published>
    <updated>2016-03-05T06:28:17.862Z</updated>
    
    <content type="html">&lt;p&gt;一些手表应用需要对用户一直保持可见。比如，正在跑步的用户可以看一眼手表以知道跑过的距离和时间。在超市购物时，记录了购物清单后，可以很快地看一眼还有那些清单上还有那些没有购买。制作一个一直可见的应用会减少电池寿命，所以添加这个功能时一定要谨慎。&lt;/p&gt;
&lt;p&gt;Android Wear允许应用保留在前台，同时节省电源。应用可以在手表进入低功耗环境模式的同时，控制手表屏幕显示的内容。同时运行在环境模式和交互模式的应用称作常驻应用。&lt;/p&gt;
&lt;h1 id=&quot;启用Ambient模式&quot;&gt;&lt;a href=&quot;#启用Ambient模式&quot; class=&quot;headerlink&quot; title=&quot;启用Ambient模式&quot;&gt;&lt;/a&gt;启用Ambient模式&lt;/h1&gt;&lt;p&gt;完成项目配置后，继承&lt;code&gt;WearableActivity&lt;/code&gt;，他提供了可以启用环境模式的所有方法。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置开发项目&quot;&gt;&lt;a href=&quot;#配置开发项目&quot; class=&quot;headerlink&quot; title=&quot;配置开发项目&quot;&gt;&lt;/a&gt;配置开发项目&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在手表应用的manifest添加手表共享库：&lt;/p&gt;
  &lt;application&gt;&lt;br&gt;    &lt;uses-library android:name=&quot;com.google.android.wearable&quot; android:required=&quot;false&quot;&gt;&lt;br&gt;    …&lt;br&gt;  &lt;/uses-library&gt;&lt;/application&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在手机和手表应用上添加&lt;code&gt;WAKE_LOCK&lt;/code&gt;权限：&lt;/p&gt;
  &lt;uses-permission android:name=&quot;android.permission.WAKE_LOCK&quot;&gt;

&lt;/uses-permission&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;创建支持环境模式的activity&quot;&gt;&lt;a href=&quot;#创建支持环境模式的activity&quot; class=&quot;headerlink&quot; title=&quot;创建支持环境模式的activity&quot;&gt;&lt;/a&gt;创建支持环境模式的activity&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;创建一个&lt;code&gt;WearableActivity&lt;/code&gt;的子类；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;onCreate()&lt;/code&gt;方法中调用&lt;code&gt;setAmbientEnabled()&lt;/code&gt;。 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MainActivity&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;WearableActivity&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    setAmbientEnabled();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;处理模式间的变化&quot;&gt;&lt;a href=&quot;#处理模式间的变化&quot; class=&quot;headerlink&quot; title=&quot;处理模式间的变化&quot;&gt;&lt;/a&gt;处理模式间的变化&lt;/h2&gt;如果在应用显示期间，用户在一段时间内不与应用交互，或者用户用手掌覆盖了屏幕，系统将会切换activity进入环境模式。应用切换至环境模式之后，将会更新activity UI至一个更加基础的布局以减轻电池消耗。应该使用黑色的背景和尽可能少的白色图片与文字。用户从交互模式进入环境模式时，应该维持一个相似的布局。&lt;blockquote&gt;
&lt;p&gt;注意：在环境模式中，应该禁用屏幕上一切的交互元素，比如按钮。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用切换进入环境模式时，系统调用&lt;code&gt;onEnterAmbient()&lt;/code&gt;方法。下面的代码在切换至环境模式后将文字颜色切换成白色，并禁用了抗锯齿功能。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onEnterAmbient&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle ambientDetails)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onEnterAmbient(ambientDetails);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mStateTextView.setTextColor(Color.WHITE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mStateTextView.getPaint().setAntiAlias(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;用户点击屏幕或者提起手腕后，activity从环境模式切换成交互模式。系统调用&lt;code&gt;onExitAmbient()&lt;/code&gt;方法。重写这个方法来更新UI布局，使应用进入在全彩、可交互的状态。&lt;/p&gt;
&lt;p&gt;下面的代码在应用进入交互模式后将文字颜色转换成绿色，并启用抗锯齿。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onExitAmbient&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onExitAmbient();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mStateTextView.setTextColor(Color.GREEN);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mStateTextView.getPaint().setAntiAlias(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;在环境模式更新内容&quot;&gt;&lt;a href=&quot;#在环境模式更新内容&quot; class=&quot;headerlink&quot; title=&quot;在环境模式更新内容&quot;&gt;&lt;/a&gt;在环境模式更新内容&lt;/h1&gt;&lt;p&gt;环境模式允许为用户更新屏幕，但必须慎重地平衡显示的更新和电池的寿命。在环境模式下，重写&lt;code&gt;onUpdateAmbient()&lt;/code&gt;方法来更新屏幕的频率最好不超过一分钟一次。为了节省电源，更新不应该超过10秒一次。&lt;/p&gt;
&lt;h2 id=&quot;每分钟更新一次&quot;&gt;&lt;a href=&quot;#每分钟更新一次&quot; class=&quot;headerlink&quot; title=&quot;每分钟更新一次&quot;&gt;&lt;/a&gt;每分钟更新一次&lt;/h2&gt;&lt;p&gt;为了节省电源，大多的手表应用不应在环境模式下频繁更新屏幕。推荐在这个模式下每分钟更新一次。系统提供了一个回调方法&lt;code&gt;onUpdateAmbient()&lt;/code&gt;来以这个推荐的频率来更新屏幕。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onUpdateAmbient&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onUpdateAmbient();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Update the content&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&quot;更加频繁地更新&quot;&gt;&lt;a href=&quot;#更加频繁地更新&quot; class=&quot;headerlink&quot; title=&quot;更加频繁地更新&quot;&gt;&lt;/a&gt;更加频繁地更新&lt;/h2&gt;&lt;p&gt;一些需要更加频繁的更新的应用比如健康，时间管理，旅行信息应用。用户使用&lt;code&gt;AlarmManager&lt;/code&gt;对象来唤醒处理器并更加频繁地更新屏幕。&lt;/p&gt;
&lt;p&gt;要实现一个在环境模式下更加频繁地更新的警报，需要：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准备alarm manager。&lt;/li&gt;
&lt;li&gt;设置更新频率。&lt;/li&gt;
&lt;li&gt;activity切换至环境模式或正处在环境模式时计划下一次更新。&lt;/li&gt;
&lt;li&gt;activity切换至交互模式或被停止时取消警报。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：alarm manager可以在触发后创建activity的新实例。要阻止这种情况，确保activity声明了&lt;code&gt;android:launchMode=&amp;quot;singleInstance&amp;quot;&lt;/code&gt;参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;准备alarm-manager&quot;&gt;&lt;a href=&quot;#准备alarm-manager&quot; class=&quot;headerlink&quot; title=&quot;准备alarm manager&quot;&gt;&lt;/a&gt;准备alarm manager&lt;/h3&gt;&lt;p&gt;Alarm manager发出pending intent以更新屏幕并计划下次警报。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; AlarmManager mAmbientStateAlarmManager;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; PendingIntent mAmbientStatePendingIntent;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCreate(savedInstanceState);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setAmbientEnabled();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mAmbientStateAlarmManager =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        (AlarmManager) getSystemService(Context.ALARM_SERVICE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Intent ambientStateIntent =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(getApplicationContext(), MainActivity.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mAmbientStatePendingIntent = PendingIntent.getActivity(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        getApplicationContext(),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ambientStateIntent,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PendingIntent.FLAG_UPDATE_CURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;Alarm触发并发出pending intent之后，在&lt;code&gt;onNewIntent()&lt;/code&gt;中更新屏幕并计划下次的alarm。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onNewIntent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Intent intent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onNewIntent(intent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setIntent(intent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Described in the following section&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    refreshDisplayAndSetNextUpdate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;更新屏幕并计划数据更新&quot;&gt;&lt;a href=&quot;#更新屏幕并计划数据更新&quot; class=&quot;headerlink&quot; title=&quot;更新屏幕并计划数据更新&quot;&gt;&lt;/a&gt;更新屏幕并计划数据更新&lt;/h3&gt;&lt;p&gt;在这个例子中，alarm manager在环境模式下每20秒触发一次。每次到时，alarm触发intent以更新屏幕并设置下次更新的延迟。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Milliseconds between waking processor/screen for updates&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; AMBIENT_INTERVAL_MS = TimeUnit.SECONDS.toMillis(&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;refreshDisplayAndSetNextUpdate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isAmbient()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Implement data retrieval and update the screen for ambient mode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Implement data retrieval and update the screen for interactive mode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; timeMs = System.currentTimeMillis();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Schedule a new alarm&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isAmbient()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Calculate the next trigger time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; delayMs = AMBIENT_INTERVAL_MS - (timeMs % AMBIENT_INTERVAL_MS);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; triggerTimeMs = timeMs + delayMs;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        mAmbientStateAlarmManager.setExact(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            AlarmManager.RTC_WAKEUP,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            triggerTimeMs,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            mAmbientStatePendingIntent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// Calculate the next trigger time for interactive mode&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;计划下个alarm&quot;&gt;&lt;a href=&quot;#计划下个alarm&quot; class=&quot;headerlink&quot; title=&quot;计划下个alarm&quot;&gt;&lt;/a&gt;计划下个alarm&lt;/h3&gt;&lt;p&gt;Activity进入环境模式或已经在环境模式时，重写&lt;code&gt;onEnterAmbient()&lt;/code&gt;和&lt;code&gt;onUpdateAmbient()&lt;/code&gt;方法来计划更新屏幕的alarm。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onEnterAmbient&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle ambientDetails)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onEnterAmbient(ambientDetails);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    refreshDisplayAndSetNextUpdate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onUpdateAmbient&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onUpdateAmbient();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    refreshDisplayAndSetNextUpdate();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;取消alarm&quot;&gt;&lt;a href=&quot;#取消alarm&quot; class=&quot;headerlink&quot; title=&quot;取消alarm&quot;&gt;&lt;/a&gt;取消alarm&lt;/h3&gt;&lt;p&gt;设备切换至交互模式后，在&lt;code&gt;onExitAmbient()&lt;/code&gt;方法中取消alarm。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onExitAmbient&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onExitAmbient();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mAmbientStateAlarmManager.cancel(mAmbientStatePendingIntent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;用户退出或终止activity之后，在&lt;code&gt;onDestroy()&lt;/code&gt;方法中取消alarm：&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onDestroy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mAmbientStateAlarmManager.cancel(mAmbientStatePendingIntent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onDestroy();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;一些手表应用需要对用户一直保持可见。比如，正在跑步的用户可以看一眼手表以知道跑过的距离和时间。在超市购物时，记录了购物清单后，可以很快地看一眼还有那些清单上还有那些没有购买。制作一个一直可见的应用会减少电池寿命，所以添加这个功能时一定要谨慎。&lt;/p&gt;
&lt;p&gt;Android Wear允许应用保留在前台，同时节省电源。应用可以在手表进入低功耗环境模式的同时，控制手表屏幕显示的内容。同时运行在环境模式和交互模式的应用称作常驻应用。&lt;/p&gt;
&lt;h1 id=&quot;启用Ambient模式&quot;&gt;&lt;a href=&quot;#启用Ambient模式&quot; class=&quot;headerlink&quot; title=&quot;启用Ambient模式&quot;&gt;&lt;/a&gt;启用Ambient模式&lt;/h1&gt;&lt;p&gt;完成项目配置后，继承&lt;code&gt;WearableActivity&lt;/code&gt;，他提供了可以启用环境模式的所有方法。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android Wear 开发 （六） 创建自定义布局</title>
    <link href="http://yoursite.com/2016/03/05/wear-dev-6/"/>
    <id>http://yoursite.com/2016/03/05/wear-dev-6/</id>
    <published>2016-03-05T03:10:05.000Z</published>
    <updated>2016-03-05T03:32:02.668Z</updated>
    
    <content type="html">&lt;h1 id=&quot;使用手表UI库创建布局&quot;&gt;&lt;a href=&quot;#使用手表UI库创建布局&quot; class=&quot;headerlink&quot; title=&quot;使用手表UI库创建布局&quot;&gt;&lt;/a&gt;使用手表UI库创建布局&lt;/h1&gt;&lt;p&gt;在Android Studio中应用向导创建应用时会自动引入手表UI库。此外也可以在&lt;code&gt;build.gradle&lt;/code&gt;中手动添加依赖声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dependencies {
    compile fileTree(dir: &amp;apos;libs&amp;apos;, include: [&amp;apos;*.jar&amp;apos;])
    compile &amp;apos;com.google.android.support:wearable:+&amp;apos;
    compile &amp;apos;com.google.android.gms:play-services-wearable:+&amp;apos;
}
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;下面是一些主要的类：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BoxInsetLayout&lt;/code&gt;：一个知道屏幕形状并且将子空间放置在圆形屏幕中心的&lt;code&gt;FrameLayout&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CardFragment&lt;/code&gt;：将内容展现在一个可扩展、可垂直滚动的fragment。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CircledImageView&lt;/code&gt;：包含在圆形中的image view。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConfirmationActivity&lt;/code&gt;：一个在用户完成动作后显示确认动画的activity。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CrossFadeDrawable&lt;/code&gt;：一个包含两个子drawable的drawable。提供方法来调整二者之间的混合度。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DelayedConfirmationView&lt;/code&gt;：一个包含了圆形倒计时器的view。一般用来在短暂的延迟时间过后，自动确认操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DismissOverlayView&lt;/code&gt;：一个用以实现长按dismiss的view。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GridViewPager&lt;/code&gt;：一个布局管理器，允许用户垂直或水平地在各个页面中导航。可以通过一个提供&lt;code&gt;GridPagerAdapter&lt;/code&gt;的实现来产生该view展示的页面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GridPagerAdapter&lt;/code&gt;：一个为&lt;code&gt;GridViewPager&lt;/code&gt;提供页面的适配器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;FragmentGridPagerAdapter&lt;/code&gt;：一个&lt;code&gt;GridPagerAdapter&lt;/code&gt;的实现，每一页使用一个fragment呈现。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DotsPageIndicator&lt;/code&gt;：一个&lt;code&gt;GridViewPager&lt;/code&gt;的页面指示器。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WatchViewStub&lt;/code&gt;：一个根据屏幕形状来填充制定布局的类。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WearableListView&lt;/code&gt;：一个&lt;code&gt;ListView&lt;/code&gt;的替换版本，为手表设备的小屏幕做了优化。它展示一个垂直可滚动的列表，并且在用户停止滚动后自动停在最近一项。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：推荐使用Android Studio进行Android Wear的开发。因为AS提供了项目安装，库引入和打包便利。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用手表UI库创建布局&quot;&gt;&lt;a href=&quot;#使用手表UI库创建布局&quot; class=&quot;headerlink&quot; title=&quot;使用手表UI库创建布局&quot;&gt;&lt;/a&gt;使用手表UI库创建布局&lt;/h1&gt;&lt;p&gt;在Android Studio中应用向导创建应用时会自动引入手表UI库。此外也可以在&lt;code&gt;build.gradle&lt;/code&gt;中手动添加依赖声明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dependencies {
    compile fileTree(dir: &amp;apos;libs&amp;apos;, include: [&amp;apos;*.jar&amp;apos;])
    compile &amp;apos;com.google.android.support:wearable:+&amp;apos;
    compile &amp;apos;com.google.android.gms:play-services-wearable:+&amp;apos;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>Check savedStateInstance Before Adding A Fragment</title>
    <link href="http://yoursite.com/2016/03/05/check-savedStateInstance-when-adding-frag/"/>
    <id>http://yoursite.com/2016/03/05/check-savedStateInstance-when-adding-frag/</id>
    <published>2016-03-05T02:49:53.000Z</published>
    <updated>2016-03-05T03:05:28.120Z</updated>
    
    <content type="html">&lt;p&gt;I found such a period of code in a project generated by Android Studio today.&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// savedInstanceState is non-null when there is fragment state&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// saved from previous configurations of this activity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// (e.g. when rotating the screen from portrait to landscape).&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// In this case, the fragment will automatically be re-added&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// to its container so we don&#39;t need to manually add it.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// For more information, see the Fragments API guide at:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// http://developer.android.com/guide/components/fragments.html&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (savedInstanceState == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Create the detail fragment and add it to the activity&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// using a fragment transaction.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Bundle arguments = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Bundle();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    arguments.putString(ItemDetailFragment.ARG_ITEM_ID,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            getIntent().getStringExtra(ItemDetailFragment.ARG_ITEM_ID));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ItemDetailFragment fragment = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ItemDetailFragment();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fragment.setArguments(arguments);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getSupportFragmentManager().beginTransaction()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .add(R.id.item_detail_container, fragment)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            .commit();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;I know the fact that after configuration changes, fragments will be added again. So you must check if fragments are already added like this:&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (fragmentManager.findFragmentById(R.id.container) == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// ...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;In fact, the saved fragment is retained by &lt;code&gt;savedStateInstance&lt;/code&gt;. Therefore, you can simply check whether &lt;code&gt;savedStateInstance&lt;/code&gt; exists to determine the existence of fragments.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;I found such a period of code in a project generated by Android Studio today.&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android Wear 开发 （五） 创建自定义通知</title>
    <link href="http://yoursite.com/2016/03/02/wear-dev-5/"/>
    <id>http://yoursite.com/2016/03/02/wear-dev-5/</id>
    <published>2016-03-02T00:46:42.000Z</published>
    <updated>2016-03-05T03:09:36.898Z</updated>
    
    <content type="html">&lt;p&gt;在手表上创建布局与手机相同，除了必须根据屏幕尺寸和瞥视动作设计以外。不要仅仅将功能和UI从手机应用中搬运至手表，这样的体验非常不好。只有在必要的时候才应该创建自定义布局。&lt;/p&gt;
&lt;h1 id=&quot;创建自定义通知&quot;&gt;&lt;a href=&quot;#创建自定义通知&quot; class=&quot;headerlink&quot; title=&quot;创建自定义通知&quot;&gt;&lt;/a&gt;创建自定义通知&lt;/h1&gt;&lt;p&gt;一般应该在手机上创建通知并自动同步至手表。这样只需创建一次通知就可以出现在多种设备上（甚至包括汽车和电视）。&lt;/p&gt;
&lt;p&gt;如果标准的通知风格不适合你的话，可以显示一个有自定义布局的activity。应该只在手表上创建和发布自定义通知，这些通知不会被同步至手机上。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在手表上创建自定义通知时，可以使用标准API(API Level 20)而非支持库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要创建自定义通知：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建布局，并为想要展示的activity设置内容视图。&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle bundle)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    setContentView(R.layout.notification_activity);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;在manifest中为activity设定必要的属性，使之能够在手表的context stream process中显示。需要将activity声明为可输出，可嵌入，并有空白的任务关系。&lt;/p&gt;
 &lt;figure class=&quot;highlight applescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;activity android:&lt;span class=&quot;property&quot;&gt;name&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;com.example.MyDisplayActivity&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     android:exported=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     android:allowEmbedded=&lt;span class=&quot;string&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     android:taskAffinity=&lt;span class=&quot;string&quot;&gt;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     android:theme=&lt;span class=&quot;string&quot;&gt;&quot;@android:style/Theme.DeviceDefault.Light&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;为想要显示的activity创建一个&lt;code&gt;PendingIntent&lt;/code&gt;。&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Intent notificationIntent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, NotificationActivity.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PendingIntent notificationPendingIntent = PendingIntent.getActivity(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, notificationIntent, PendingIntent.FLAG_UPDATE_CURRENT);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建一个&lt;code&gt;Notification&lt;/code&gt;，然后调用&lt;code&gt;setDisplayIntent()&lt;/code&gt;并传入&lt;code&gt;PendingIntent&lt;/code&gt;。系统使用这个&lt;code&gt;PendingIntent&lt;/code&gt;在用户查看通知的时候启动activity。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;notify()&lt;/code&gt;方法发送通知。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：当通知再主屏幕上显示时，系统使用由通知语义产生的标准模板来展示。这个模板在所有表盘上都可以工作。用户上滑通知后，会看到通知的自定义activity。&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在手表上创建布局与手机相同，除了必须根据屏幕尺寸和瞥视动作设计以外。不要仅仅将功能和UI从手机应用中搬运至手表，这样的体验非常不好。只有在必要的时候才应该创建自定义布局。&lt;/p&gt;
&lt;h1 id=&quot;创建自定义通知&quot;&gt;&lt;a href=&quot;#创建自定义通知&quot; class=&quot;headerlink&quot; title=&quot;创建自定义通知&quot;&gt;&lt;/a&gt;创建自定义通知&lt;/h1&gt;&lt;p&gt;一般应该在手机上创建通知并自动同步至手表。这样只需创建一次通知就可以出现在多种设备上（甚至包括汽车和电视）。&lt;/p&gt;
&lt;p&gt;如果标准的通知风格不适合你的话，可以显示一个有自定义布局的activity。应该只在手表上创建和发布自定义通知，这些通知不会被同步至手机上。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android Wear 开发 （四） 创建和运行手表应用</title>
    <link href="http://yoursite.com/2016/02/27/Wear-Dev-4/"/>
    <id>http://yoursite.com/2016/02/27/Wear-Dev-4/</id>
    <published>2016-02-27T13:33:07.000Z</published>
    <updated>2016-03-02T15:11:40.018Z</updated>
    
    <content type="html">&lt;h1 id=&quot;更新SDK&quot;&gt;&lt;a href=&quot;#更新SDK&quot; class=&quot;headerlink&quot; title=&quot;更新SDK&quot;&gt;&lt;/a&gt;更新SDK&lt;/h1&gt;&lt;p&gt;开始创建穿戴应用前，首先：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新SDK工具至23.0.0或以上&lt;/li&gt;
&lt;li&gt;更新SDK至API20或以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;设置手表设备&quot;&gt;&lt;a href=&quot;#设置手表设备&quot; class=&quot;headerlink&quot; title=&quot;设置手表设备&quot;&gt;&lt;/a&gt;设置手表设备&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在手机上安装Android Wear应用。&lt;/li&gt;
&lt;li&gt;根据指示与手表配对。&lt;/li&gt;
&lt;li&gt;保持Android Wear在手机上打开。&lt;/li&gt;
&lt;li&gt;在手表上启用adb调试。&lt;ol&gt;
&lt;li&gt;进入&lt;strong&gt;Settings &amp;gt; About&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;点击&lt;strong&gt;Build number&lt;/strong&gt;七次。&lt;/li&gt;
&lt;li&gt;右滑返回设置目录。&lt;/li&gt;
&lt;li&gt;进入屏幕底端的开发者设置。&lt;/li&gt;
&lt;li&gt;点击ADB调试来启用adb。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通过USB连接手表到机器上，这样可以直接安装应用。Android Wear应用和手表上都会显示一条消息表示允许调试。（如果不能通过USB连接，可以尝试使用蓝牙）&lt;/li&gt;
&lt;li&gt;在Android Wear应用上，勾选总是允许这台电脑，并点击OK。&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;创建项目&quot;&gt;&lt;a href=&quot;#创建项目&quot; class=&quot;headerlink&quot; title=&quot;创建项目&quot;&gt;&lt;/a&gt;创建项目&lt;/h1&gt;&lt;p&gt;要开始开发，首先创建一个包含手表和手机模组的应用项目。在Android Studio中创建最为方法，只需按照向导的说明即可。&lt;/p&gt;
&lt;p&gt;向导结束后，Android Studio会创建一个包含手机模组和手表模组的新项目。可以在这个项目中为两者创建activiy，service和自定义布局。手机应用执行重量级的任务，比如网络通讯，密集处理，或大量用户交互的任务。应用完成操作后，应该通过通知或同步发送数据的方式将结果告知手表。&lt;/p&gt;
&lt;h1 id=&quot;安装手表应用&quot;&gt;&lt;a href=&quot;#安装手表应用&quot; class=&quot;headerlink&quot; title=&quot;安装手表应用&quot;&gt;&lt;/a&gt;安装手表应用&lt;/h1&gt;&lt;p&gt;在手表上直接安装应用就像和在手机上一样。使用&lt;code&gt;adb install&lt;/code&gt;或AS上的&lt;strong&gt;Play&lt;/strong&gt;按钮。&lt;/p&gt;
&lt;p&gt;准备发布应用时，应该将手表应用嵌入至手机应用中。用户通过Google Play安装手机应用后，连接的手表自动接收手表应用。&lt;/p&gt;
&lt;h1 id=&quot;引入正确的库&quot;&gt;&lt;a href=&quot;#引入正确的库&quot; class=&quot;headerlink&quot; title=&quot;引入正确的库&quot;&gt;&lt;/a&gt;引入正确的库&lt;/h1&gt;&lt;p&gt;作为项目向导的一部分，模组的&lt;code&gt;build.gradle&lt;/code&gt;中引入了正确的依赖。然而，这些依赖并非必要的。&lt;/p&gt;
&lt;h2 id=&quot;通知&quot;&gt;&lt;a href=&quot;#通知&quot; class=&quot;headerlink&quot; title=&quot;通知&quot;&gt;&lt;/a&gt;通知&lt;/h2&gt;&lt;p&gt;Android v4 support library包含了扩展手机通知已支持手表的API。&lt;/p&gt;
&lt;p&gt;只显示在手表上的通知（即手表应用发出的通知），可以使用标准的框架API（API Level 20)，并在手表模组上移除这个支持库的依赖。&lt;/p&gt;
&lt;h2 id=&quot;手表数据层&quot;&gt;&lt;a href=&quot;#手表数据层&quot; class=&quot;headerlink&quot; title=&quot;手表数据层&quot;&gt;&lt;/a&gt;手表数据层&lt;/h2&gt;&lt;p&gt;要在手表和手机间通过手表数据层同步和发送数据，需要Google Play服务的最新版。如果没有使用这些API，可以从两个模组中移除依赖。&lt;/p&gt;
&lt;h2 id=&quot;手表UI支持库&quot;&gt;&lt;a href=&quot;#手表UI支持库&quot; class=&quot;headerlink&quot; title=&quot;手表UI支持库&quot;&gt;&lt;/a&gt;手表UI支持库&lt;/h2&gt;&lt;p&gt;这是一个包含了手表UI空间的非官方的库。谷歌鼓励在应用中使用他们，因为他们是很好的模范。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;更新SDK&quot;&gt;&lt;a href=&quot;#更新SDK&quot; class=&quot;headerlink&quot; title=&quot;更新SDK&quot;&gt;&lt;/a&gt;更新SDK&lt;/h1&gt;&lt;p&gt;开始创建穿戴应用前，首先：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;更新SDK工具至23.0.0或以上&lt;/li&gt;
&lt;li&gt;更新SDK至API20或以上&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;设置手表设备&quot;&gt;&lt;a href=&quot;#设置手表设备&quot; class=&quot;headerlink&quot; title=&quot;设置手表设备&quot;&gt;&lt;/a&gt;设置手表设备&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;在手机上安装Android Wear应用。&lt;/li&gt;
&lt;li&gt;根据指示与手表配对。&lt;/li&gt;
&lt;li&gt;保持Android Wear在手机上打开。&lt;/li&gt;
&lt;li&gt;在手表上启用adb调试。&lt;ol&gt;
&lt;li&gt;进入&lt;strong&gt;Settings &amp;gt; About&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;点击&lt;strong&gt;Build number&lt;/strong&gt;七次。&lt;/li&gt;
&lt;li&gt;右滑返回设置目录。&lt;/li&gt;
&lt;li&gt;进入屏幕底端的开发者设置。&lt;/li&gt;
&lt;li&gt;点击ADB调试来启用adb。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通过USB连接手表到机器上，这样可以直接安装应用。Android Wear应用和手表上都会显示一条消息表示允许调试。（如果不能通过USB连接，可以尝试使用蓝牙）&lt;/li&gt;
&lt;li&gt;在Android Wear应用上，勾选总是允许这台电脑，并点击OK。
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android Wear 开发 （三） 在通知中添加页面</title>
    <link href="http://yoursite.com/2016/02/27/Wear-Dev-3/"/>
    <id>http://yoursite.com/2016/02/27/Wear-Dev-3/</id>
    <published>2016-02-27T13:27:51.000Z</published>
    <updated>2016-02-27T13:32:40.136Z</updated>
    
    <content type="html">&lt;p&gt;要创建多页面的通知：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;NotificationCompat.Builder&lt;/code&gt;创建主通知（第一页），就像在手机上呈现一样。&lt;/li&gt;
&lt;li&gt;同样使用&lt;code&gt;NotificationCompat.Builder&lt;/code&gt;创建其他页面。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;通过&lt;code&gt;addPage()&lt;/code&gt;将这些页面添加至主通知，或添加&lt;code&gt;Collection&lt;/code&gt;中的页面。&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create builder for the main notification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationCompat.Builder notificationBuilder =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Builder(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setSmallIcon(R.drawable.new_message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentTitle(&lt;span class=&quot;string&quot;&gt;&quot;Page 1&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentText(&lt;span class=&quot;string&quot;&gt;&quot;Short message&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentIntent(viewPendingIntent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create a big text style for the second page&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BigTextStyle secondPageStyle = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.BigTextStyle();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;secondPageStyle.setBigContentTitle(&lt;span class=&quot;string&quot;&gt;&quot;Page 2&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               .bigText(&lt;span class=&quot;string&quot;&gt;&quot;A lot of text...&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create second page notification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Notification secondPageNotification =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Builder(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setStyle(secondPageStyle)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Extend the notification builder with the second page&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Notification notification = notificationBuilder&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .extend(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.WearableExtender()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .addPage(secondPageNotification))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Issue the notification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;notificationManager =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NotificationManagerCompat.from(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;notificationManager.notify(notificationId, notification);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;要创建多页面的通知：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用&lt;code&gt;NotificationCompat.Builder&lt;/code&gt;创建主通知（第一页），就像在手机上呈现一样。&lt;/li&gt;
&lt;li&gt;同样使用&lt;code&gt;NotificationCompat.Builder&lt;/co
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android Wear 开发 （二） 在通知中接收语音输入</title>
    <link href="http://yoursite.com/2016/02/27/Wear-Dev-2/"/>
    <id>http://yoursite.com/2016/02/27/Wear-Dev-2/</id>
    <published>2016-02-27T12:53:14.000Z</published>
    <updated>2016-02-27T13:27:28.651Z</updated>
    
    <content type="html">&lt;p&gt;在手机上，有需要输入文字的通知时，一般会启动一个activity以供输入。然而在手表上没有键盘输入，可以让用户通过语音回复或者通过&lt;code&gt;RemoteInput&lt;/code&gt;选择预先定义的文字消息。&lt;/p&gt;
&lt;p&gt;用户使用语音回复或者选择某条消息时，系统将文字回应附在为通知指定的&lt;code&gt;Intent&lt;/code&gt;上，发送至手机应用中。&lt;/p&gt;
&lt;h1 id=&quot;定义语音输入&quot;&gt;&lt;a href=&quot;#定义语音输入&quot; class=&quot;headerlink&quot; title=&quot;定义语音输入&quot;&gt;&lt;/a&gt;定义语音输入&lt;/h1&gt;&lt;p&gt;要创建一个支持语音输入的动作，首先创建一个&lt;code&gt;RemoteInput.Builder&lt;/code&gt;的实例，它可以添加至通知动作中。这个类的构造器接受一个字符串，系统使用它作为语音输入的key，之后使用它在手机上取回输入的文字。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Key for the string that&#39;s delivered in the action&#39;s intent&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String EXTRA_VOICE_REPLY = &lt;span class=&quot;string&quot;&gt;&quot;extra_voice_reply&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String replyLabel = getResources().getString(R.string.reply_label);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RemoteInput remoteInput = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RemoteInput.Builder(EXTRA_VOICE_REPLY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setLabel(replyLabel)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;添加预定义文字回复&quot;&gt;&lt;a href=&quot;#添加预定义文字回复&quot; class=&quot;headerlink&quot; title=&quot;添加预定义文字回复&quot;&gt;&lt;/a&gt;添加预定义文字回复&lt;/h2&gt;&lt;p&gt;调用&lt;code&gt;setChoices()&lt;/code&gt;并传入字符串数组即可。&lt;/p&gt;
&lt;p&gt;比如在资源数组中定义一些响应：&lt;/p&gt;
&lt;p&gt;res/values/strings.xml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;resources&amp;gt;
    &amp;lt;string-array name=&amp;quot;reply_choices&amp;quot;&amp;gt;
        &amp;lt;item&amp;gt;Yes&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;No&amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;Maybe&amp;lt;/item&amp;gt;
    &amp;lt;/string-array&amp;gt;
&amp;lt;/resources&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后填充字符串数组，并添加至&lt;code&gt;RemoteInput&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String EXTRA_VOICE_REPLY = &lt;span class=&quot;string&quot;&gt;&quot;extra_voice_reply&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String replyLabel = getResources().getString(R.string.reply_label);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String[] replyChoices = getResources().getStringArray(R.array.reply_choices);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RemoteInput remoteInput = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RemoteInput.Builder(EXTRA_VOICE_REPLY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setLabel(replyLabel)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setChoices(replyChoices)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;添加语音输入作为通知动作&quot;&gt;&lt;a href=&quot;#添加语音输入作为通知动作&quot; class=&quot;headerlink&quot; title=&quot;添加语音输入作为通知动作&quot;&gt;&lt;/a&gt;添加语音输入作为通知动作&lt;/h1&gt;&lt;p&gt;要设置语音输入，调用&lt;code&gt;addRemoteInput()&lt;/code&gt;将&lt;code&gt;RemoteInput&lt;/code&gt;对象附给一个动作。然后在通知上应用动作。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create an intent for the reply action&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Intent replyIntent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, ReplyActivity.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PendingIntent replyPendingIntent =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PendingIntent.getActivity(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, replyIntent,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                PendingIntent.FLAG_UPDATE_CURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create the reply action and add the remote input&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationCompat.Action action =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Action.Builder(R.drawable.ic_reply_icon,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getString(R.string.label), replyPendingIntent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .addRemoteInput(remoteInput)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Build the notification and add the action via WearableExtender&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Notification notification =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Builder(mContext)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .setSmallIcon(R.drawable.ic_message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .setContentTitle(getString(R.string.title))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .setContentText(getString(R.string.content))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .extend(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; WearableExtender().addAction(action))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Issue the notification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationManagerCompat notificationManager =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NotificationManagerCompat.from(mContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;notificationManager.notify(notificationId, notification);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;接收语音输入作为字符串&quot;&gt;&lt;a href=&quot;#接收语音输入作为字符串&quot; class=&quot;headerlink&quot; title=&quot;接收语音输入作为字符串&quot;&gt;&lt;/a&gt;接收语音输入作为字符串&lt;/h1&gt;&lt;p&gt;调用&lt;code&gt;getResultFromIntent()&lt;/code&gt;方法，传入回复的动作的intent，就可以在回复动作intent所声明的activity中，收到用户转录出的消息。这个方法返回一个&lt;code&gt;Bundle&lt;/code&gt;来包含文字响应。可以查询&lt;code&gt;Bundle&lt;/code&gt;以获得响应。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意不要使用&lt;code&gt;Intent.getExtras()&lt;/code&gt;来获得语音结果，因为语音输入以&lt;code&gt;ClipData&lt;/code&gt;进行存储。&lt;code&gt;getResultFromIntent()&lt;/code&gt;方法提供便利的获取字符序列的方法，无需手动处理&lt;code&gt;ClipData&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的代码显示了一个方法，它接收一个intent，返回&lt;code&gt;EXTRA_VOICE_REPLY&lt;/code&gt;key的语音响应。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Obtain the intent that started this activity by calling&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * Activity.getIntent() and pass it into this method to&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; * get the associated voice input string.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; CharSequence &lt;span class=&quot;title&quot;&gt;getMessageText&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Intent intent)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Bundle remoteInput = RemoteInput.getResultsFromIntent(intent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (remoteInput != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; remoteInput.getCharSequence(EXTRA_VOICE_REPLY);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;在手机上，有需要输入文字的通知时，一般会启动一个activity以供输入。然而在手表上没有键盘输入，可以让用户通过语音回复或者通过&lt;code&gt;RemoteInput&lt;/code&gt;选择预先定义的文字消息。&lt;/p&gt;
&lt;p&gt;用户使用语音回复或者选择某条消息时，系统将文字回应附在为通知指定的&lt;code&gt;Intent&lt;/code&gt;上，发送至手机应用中。&lt;/p&gt;
&lt;h1 id=&quot;定义语音输入&quot;&gt;&lt;a href=&quot;#定义语音输入&quot; class=&quot;headerlink&quot; title=&quot;定义语音输入&quot;&gt;&lt;/a&gt;定义语音输入&lt;/h1&gt;&lt;p&gt;要创建一个支持语音输入的动作，首先创建一个&lt;code&gt;RemoteInput.Builder&lt;/code&gt;的实例，它可以添加至通知动作中。这个类的构造器接受一个字符串，系统使用它作为语音输入的key，之后使用它在手机上取回输入的文字。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Key for the string that&#39;s delivered in the action&#39;s intent&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; String EXTRA_VOICE_REPLY = &lt;span class=&quot;string&quot;&gt;&quot;extra_voice_reply&quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String replyLabel = getResources().getString(R.string.reply_label);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RemoteInput remoteInput = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RemoteInput.Builder(EXTRA_VOICE_REPLY)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setLabel(replyLabel)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>Android Wear 开发 （一） 创建手表通知</title>
    <link href="http://yoursite.com/2016/02/27/Wear-Dev-1/"/>
    <id>http://yoursite.com/2016/02/27/Wear-Dev-1/</id>
    <published>2016-02-27T11:54:50.000Z</published>
    <updated>2016-02-27T12:52:50.753Z</updated>
    
    <content type="html">&lt;p&gt;I bought a moto 360 last year. But I seldom wear it, because it’s kind of useless. No app in Android Wear is irreplaceable. Many people never wears it in life because a cellphone is enough. So it’s necessary to develop a functional Wearable app whose performance is better in wearable devices than in cellphones.&lt;/p&gt;
&lt;h1 id=&quot;Getting-Started&quot;&gt;&lt;a href=&quot;#Getting-Started&quot; class=&quot;headerlink&quot; title=&quot;Getting Started&quot;&gt;&lt;/a&gt;Getting Started&lt;/h1&gt;&lt;p&gt;首先来看 &lt;code&gt;Notification&lt;/code&gt;. 要创建同时发送到手表的手机通知，使用 &lt;code&gt;NotificationCompat.Builder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在gradle中引入需要的包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile &amp;quot;com.android.support:support-v4:20.0.+&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通知呈现在手机上时，用户触碰通知，调用&lt;code&gt;setContentIntent()&lt;/code&gt;指定的 &lt;code&gt;PendingIntent&lt;/code&gt; 。而在手表上，用户将通知滑动至左边以显示&lt;strong&gt;Open&lt;/strong&gt;动作，后者调用手机上的intent。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;添加动作按钮&quot;&gt;&lt;a href=&quot;#添加动作按钮&quot; class=&quot;headerlink&quot; title=&quot;添加动作按钮&quot;&gt;&lt;/a&gt;添加动作按钮&lt;/h1&gt;&lt;p&gt;除了&lt;code&gt;setContentIntent()&lt;/code&gt;定义的主内容动作外，可以传递&lt;code&gt;PendingIntent&lt;/code&gt;给&lt;code&gt;addAction()&lt;/code&gt;方法添加其他的动作。&lt;/p&gt;
&lt;p&gt;下面的代码增加了一个查看地图的动作：&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Build an intent for an action to view a map&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Intent mapIntent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_VIEW);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Uri geoUri = Uri.parse(&lt;span class=&quot;string&quot;&gt;&quot;geo:0,0?q=&quot;&lt;/span&gt; + Uri.encode(location));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mapIntent.setData(geoUri);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PendingIntent mapPendingIntent =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PendingIntent.getActivity(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, mapIntent, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationCompat.Builder notificationBuilder =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Builder(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setSmallIcon(R.drawable.ic_event)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentTitle(eventTitle)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentText(eventLocation)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentIntent(viewPendingIntent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addAction(R.drawable.ic_map,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getString(R.string.map), mapPendingIntent);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;在手机上，这个动作显示为通知上附加的一个按钮。在手表上，这个动作显示为滑动通知后的大按钮。用户触发后，会在手机上调用关联的intent。&lt;/p&gt;
&lt;h1 id=&quot;指定手表动作&quot;&gt;&lt;a href=&quot;#指定手表动作&quot; class=&quot;headerlink&quot; title=&quot;指定手表动作&quot;&gt;&lt;/a&gt;指定手表动作&lt;/h1&gt;&lt;p&gt;如果希望手表上的动作与手机不同。可以使用&lt;code&gt;WearableExtender.addAction()&lt;/code&gt;方法。一旦使用这个方法添加了动作，使用&lt;code&gt;NotificationCompat.Builder.addAction()&lt;/code&gt;添加的方法将都不会被手表显示。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create an intent for the reply action&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Intent actionIntent = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, ActionActivity.class);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PendingIntent actionPendingIntent =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        PendingIntent.getActivity(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, actionIntent,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                PendingIntent.FLAG_UPDATE_CURRENT);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create the action&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationCompat.Action action =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Action.Builder(R.drawable.ic_action,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getString(R.string.label), actionPendingIntent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .build();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Build the notification and add the action via WearableExtender&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Notification notification =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Builder(mContext)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .setSmallIcon(R.drawable.ic_message)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .setContentTitle(getString(R.string.title))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .setContentText(getString(R.string.content))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .extend(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; WearableExtender().addAction(action))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                .build();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&quot;添加大视图&quot;&gt;&lt;a href=&quot;#添加大视图&quot; class=&quot;headerlink&quot; title=&quot;添加大视图&quot;&gt;&lt;/a&gt;添加大视图&lt;/h1&gt;&lt;p&gt;通过大视图可以在通知中插入扩展的文字内容。在手机上，用户可以展开通知来查看大视图的内容。而在手表上则是默认可见。&lt;/p&gt;
&lt;p&gt;要添加扩展内容，调用&lt;code&gt;NotificationCompat.Builder&lt;/code&gt;的&lt;code&gt;setStyle()&lt;/code&gt; 方法，传入一个&lt;code&gt;BigTextStyle&lt;/code&gt;或&lt;code&gt;InboxStyle&lt;/code&gt;实例。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Specify the &#39;big view&#39; content to display the long&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// event description that may not fit the normal content text.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;BigTextStyle bigStyle = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.BigTextStyle();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bigStyle.bigText(eventDescription);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationCompat.Builder notificationBuilder =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Builder(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setSmallIcon(R.drawable.ic_event)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setLargeIcon(BitmapFactory.decodeResource(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getResources(), R.drawable.notif_background))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentTitle(eventTitle)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentText(eventLocation)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentIntent(viewPendingIntent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .addAction(R.drawable.ic_map,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                getString(R.string.map), mapPendingIntent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setStyle(bigStyle);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;setLargeIcon()&lt;/code&gt;方法可以为任意的通知添加一个大图标。然而，这些图标在手表上显示为大的背景图片，因为缩放的原因会不太好看。&lt;/p&gt;
&lt;h1 id=&quot;为通知添加手表功能&quot;&gt;&lt;a href=&quot;#为通知添加手表功能&quot; class=&quot;headerlink&quot; title=&quot;为通知添加手表功能&quot;&gt;&lt;/a&gt;为通知添加手表功能&lt;/h1&gt;&lt;p&gt;如果需要为通知添加手表专用的选项，比如指定获取用户的语言输入，可以调用&lt;code&gt;NotificationCompat.WearableExtender&lt;/code&gt;类来指定选项。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建&lt;code&gt;WearableExtender&lt;/code&gt;实例，设置选项；&lt;/li&gt;
&lt;li&gt;创建&lt;code&gt;NotificationCompat.Builder&lt;/code&gt;实例，设置属性；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;extend()&lt;/code&gt;并传入&lt;code&gt;WearableExtender&lt;/code&gt;，应用手表的设置；&lt;/li&gt;
&lt;li&gt;&lt;p&gt;调用&lt;code&gt;build()&lt;/code&gt;来建造通知。&lt;/p&gt;
 &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create a WearableExtender to add functionality for wearables&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationCompat.WearableExtender wearableExtender =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.WearableExtender()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setHintHideIcon(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setBackground(mBitmap);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Create a NotificationCompat.Builder to build a standard notification&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// then extend it with the WearableExtender&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Notification notif = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; NotificationCompat.Builder(mContext)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentTitle(&lt;span class=&quot;string&quot;&gt;&quot;New mail from &quot;&lt;/span&gt; + sender)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setContentText(subject)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .setSmallIcon(R.drawable.new_mail)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .extend(wearableExtender)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        .build();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;发送通知&quot;&gt;&lt;a href=&quot;#发送通知&quot; class=&quot;headerlink&quot; title=&quot;发送通知&quot;&gt;&lt;/a&gt;发送通知&lt;/h1&gt;&lt;p&gt;发送通知时，一定要使用&lt;code&gt;NotificationManagerCompat&lt;/code&gt;API而非&lt;code&gt;NotificationManager&lt;/code&gt;，以确保手表的功能能够正常使用。&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Get an instance of the NotificationManager service&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;NotificationManagerCompat notificationManager =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        NotificationManagerCompat.from(mContext);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Issue the notification with notification manager.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;notificationManager.notify(notificationId, notif);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;I bought a moto 360 last year. But I seldom wear it, because it’s kind of useless. No app in Android Wear is irreplaceable. Many people never wears it in life because a cellphone is enough. So it’s necessary to develop a functional Wearable app whose performance is better in wearable devices than in cellphones.&lt;/p&gt;
&lt;h1 id=&quot;Getting-Started&quot;&gt;&lt;a href=&quot;#Getting-Started&quot; class=&quot;headerlink&quot; title=&quot;Getting Started&quot;&gt;&lt;/a&gt;Getting Started&lt;/h1&gt;&lt;p&gt;首先来看 &lt;code&gt;Notification&lt;/code&gt;. 要创建同时发送到手表的手机通知，使用 &lt;code&gt;NotificationCompat.Builder&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在gradle中引入需要的包：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;compile &amp;quot;com.android.support:support-v4:20.0.+&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通知呈现在手机上时，用户触碰通知，调用&lt;code&gt;setContentIntent()&lt;/code&gt;指定的 &lt;code&gt;PendingIntent&lt;/code&gt; 。而在手表上，用户将通知滑动至左边以显示&lt;strong&gt;Open&lt;/strong&gt;动作，后者调用手机上的intent。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android Wear" scheme="http://yoursite.com/tags/Android-Wear/"/>
    
  </entry>
  
  <entry>
    <title>testing</title>
    <link href="http://yoursite.com/2016/02/27/testing/"/>
    <id>http://yoursite.com/2016/02/27/testing/</id>
    <published>2016-02-27T03:04:19.000Z</published>
    <updated>2016-02-27T03:04:19.824Z</updated>
    
    <content type="html"></content>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Procedures of Restoring My Blog with Hexo</title>
    <link href="http://yoursite.com/2016/02/27/resetting-hexo/"/>
    <id>http://yoursite.com/2016/02/27/resetting-hexo/</id>
    <published>2016-02-27T02:49:22.000Z</published>
    <updated>2016-02-27T03:22:09.615Z</updated>
    
    <content type="html">&lt;p&gt;Today I spent an entire morning fixing a bug of hexo. However, I failed to fix it and leaving my blog unable to update. After trying various solutions, I decided to reconstruct my blog. Now I will record the process of resetting my blog.&lt;/p&gt;
&lt;h1 id=&quot;Initialize-Hexo&quot;&gt;&lt;a href=&quot;#Initialize-Hexo&quot; class=&quot;headerlink&quot; title=&quot;Initialize Hexo&quot;&gt;&lt;/a&gt;Initialize Hexo&lt;/h1&gt;&lt;p&gt;First, delete the old repo in Github, and re-init a hexo directory:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo init my-hexo-website

cd my-hexo-website
npm install
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Configure-Git&quot;&gt;&lt;a href=&quot;#Configure-Git&quot; class=&quot;headerlink&quot; title=&quot;Configure Git&quot;&gt;&lt;/a&gt;Configure Git&lt;/h1&gt;&lt;p&gt;Inside your hexo-website folder, use the command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init 
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Add the important files to Git and then commit those files as the first change:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add _config.yml packages.json .gitignore scaffolds/*.md 
git commit -m &amp;quot;Adding a new Hexo website&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Create-a-Repository-on-Github&quot;&gt;&lt;a href=&quot;#Create-a-Repository-on-Github&quot; class=&quot;headerlink&quot; title=&quot;Create a Repository on Github&quot;&gt;&lt;/a&gt;Create a Repository on Github&lt;/h1&gt;&lt;p&gt;Sign into your account on Github and create a new repository.&lt;/p&gt;
&lt;p&gt;Choose SSH in quick setup.&lt;/p&gt;
&lt;p&gt;Add this new repository to your local git repository&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git remote add origin git@github.com:sphiatower/sphiatower.github.io.git
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Then I copied all articles and themes back to my new directory. However I got an error when deploying:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deployer not found github
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This solution is changing &lt;code&gt;type: github&lt;/code&gt; into &lt;code&gt;type: git&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;deploy:
  type: git
  repository: https://github.com/username/username.github.com.git
  branch: master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Finally, my blog managed to work as before.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;Today I spent an entire morning fixing a bug of hexo. However, I failed to fix it and leaving my blog unable to update. After trying various solutions, I decided to reconstruct my blog. Now I will record the process of resetting my blog.&lt;/p&gt;
&lt;h1 id=&quot;Initialize-Hexo&quot;&gt;&lt;a href=&quot;#Initialize-Hexo&quot; class=&quot;headerlink&quot; title=&quot;Initialize Hexo&quot;&gt;&lt;/a&gt;Initialize Hexo&lt;/h1&gt;&lt;p&gt;First, delete the old repo in Github, and re-init a hexo directory:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;hexo init my-hexo-website

cd my-hexo-website
npm install
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;Configure-Git&quot;&gt;&lt;a href=&quot;#Configure-Git&quot; class=&quot;headerlink&quot; title=&quot;Configure Git&quot;&gt;&lt;/a&gt;Configure Git&lt;/h1&gt;&lt;p&gt;Inside your hexo-website folder, use the command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git init 
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Understanding the Visitor Pattern - Double Dispatch</title>
    <link href="http://yoursite.com/2016/02/15/visitor-double-dispatch/"/>
    <id>http://yoursite.com/2016/02/15/visitor-double-dispatch/</id>
    <published>2016-02-15T13:28:29.000Z</published>
    <updated>2016-02-21T14:42:49.617Z</updated>
    
    <content type="html">&lt;p&gt;For the visitor pattern, it’s not difficult to remember its syntax or use it. But why we must use a visitor pattern instead of a static method (a function) or other workarounds?&lt;/p&gt;
&lt;h1 id=&quot;Static-methods&quot;&gt;&lt;a href=&quot;#Static-methods&quot; class=&quot;headerlink&quot; title=&quot;Static methods&quot;&gt;&lt;/a&gt;Static methods&lt;/h1&gt;&lt;p&gt;For a specified class hierarchy, when it comes to adding a method for every class without modifying themselves, what comes into my mind at first is to create a set of functions, i.e. a static method in java, each taking an instance of that class.&lt;/p&gt;
&lt;p&gt;For example, if I want to add a method to &lt;code&gt;ICarElement&lt;/code&gt; and its implementations, &lt;code&gt;Wheel&lt;/code&gt;, &lt;code&gt;Engine&lt;/code&gt; and &lt;code&gt;Body&lt;/code&gt;, I could write such a class as a set of functions:&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CarElementFuncs&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Wheel wheel)&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Engine engine)&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Body body)&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;If I need a different implementation, I could write another class like &lt;code&gt;CarElementFuncs2&lt;/code&gt;. And if I want to make it more flexible at runtime, I could even make these classes singletons or use strategy pattern. But what is lacked?&lt;/p&gt;
&lt;h1 id=&quot;Java-reflect&quot;&gt;&lt;a href=&quot;#Java-reflect&quot; class=&quot;headerlink&quot; title=&quot;Java reflect&quot;&gt;&lt;/a&gt;Java reflect&lt;/h1&gt;&lt;p&gt;The key of visitor pattern is the double dispatch. Even if it’s possible to change the behavior of &lt;code&gt;visit()&lt;/code&gt; function at runtime, the key shortcoming is that you cannot apply these functions on an &lt;code&gt;ICarElement&lt;/code&gt; at compile time. If you add a function to your function set like:&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CarElementFuncs&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;comment&quot;&gt;// ......&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ICarElement element)&lt;/span&gt; &lt;/span&gt;&amp;#123;...&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;There’s no way for the &lt;code&gt;visit(ICarElement)&lt;/code&gt; to know the runtime type of &lt;code&gt;ICarElement&lt;/code&gt;, except using reflect like &lt;code&gt;instanceof&lt;/code&gt;. If so the code becomes:&lt;br&gt;    &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CarElementFuncs&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ICarElement element)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (element &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Wheel) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (element &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; Engine) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;//...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;Then the code becomes an iteration through all possible classes in the hierarchy every time. It’s obviously not a good solution. Because when it comes to java reflect, there’s always a sense of code smell.&lt;/p&gt;
&lt;h1 id=&quot;Double-dispatch&quot;&gt;&lt;a href=&quot;#Double-dispatch&quot; class=&quot;headerlink&quot; title=&quot;Double dispatch&quot;&gt;&lt;/a&gt;Double dispatch&lt;/h1&gt;&lt;p&gt;So here comes the visitor pattern.&lt;/p&gt;
&lt;p&gt;Given a instance of a parent type like &lt;code&gt;ICarElement&lt;/code&gt;, you have no idea of what its runtime type is without using reflect. So, if you want to add a behavior to all subtypes of &lt;code&gt;ICarElement&lt;/code&gt;, taking their instances as arguments will not work. You must modify the class themselves. Only within the class scope, you can know the type of a specified instance by &lt;code&gt;this&lt;/code&gt;. So the code should be like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ICarElement&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ICarElementVisitor visitor)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ICarElementVisitor&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Wheel wheel)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Engine engine)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;visit&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Body body)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Wheel&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ICarElement&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;accept&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ICarElementVisitor visitor)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		visitor.visit(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;When an &lt;code&gt;ICarElement&lt;/code&gt; instance accepts a visitor, the runtime type is passed to the &lt;code&gt;visit()&lt;/code&gt; method by &lt;code&gt;this&lt;/code&gt;. And the behavior of &lt;code&gt;ICarElementVisitor&lt;/code&gt; is also decided at runtime. Therefore, with the visitor pattern, only given two abstract interface &lt;code&gt;ICarElement&lt;/code&gt; and &lt;code&gt;ICarElementVisitor&lt;/code&gt; at compile time, you can output a variety of different possibilities of implementations at runtime, without largely modifying the code of the class hierarchy. This is the true power of the visitor pattern.&lt;/p&gt;
&lt;h1 id=&quot;A-debate-on-performance&quot;&gt;&lt;a href=&quot;#A-debate-on-performance&quot; class=&quot;headerlink&quot; title=&quot;A debate on performance&quot;&gt;&lt;/a&gt;A debate on performance&lt;/h1&gt;&lt;p&gt;I found &lt;a href=&quot;http://stackoverflow.com/questions/3930808/how-to-avoid-large-if-statements-and-instanceof/16423712#16423712&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;an interesting debate&lt;/a&gt; when searching questions on the visitor pattern. Some people found that using &lt;code&gt;instanceof&lt;/code&gt; is even faster than the visitor pattern under some circumstances. But here’s a piece of argument on the side of visitor pattern:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I think it’s fair to bring this up. However in the vast majority cases, ease of maintenance will far outweigh a modest performance gain. With the visitor pattern, adding a new type of animal will expose immediately any places that need to be updated, as any previously existing visitors will now fail to compile. If-else chains using instanceof will happily compile and there is a good chance that you will not discover you have effected the foreign module until the incorrect behavior is noticed. &lt;/p&gt;
&lt;/blockquote&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;For the visitor pattern, it’s not difficult to remember its syntax or use it. But why we must use a visitor pattern instead of a static method (a function) or other workarounds?&lt;/p&gt;
&lt;h1 id=&quot;Static-methods&quot;&gt;&lt;a href=&quot;#Static-methods&quot; class=&quot;headerlink&quot; title=&quot;Static methods&quot;&gt;&lt;/a&gt;Static methods&lt;/h1&gt;&lt;p&gt;For a specified class hierarchy, when it comes to adding a method for every class without modifying themselves, what comes into my mind at first is to create a set of functions, i.e. a static method in java, each taking an instance of that class.&lt;/p&gt;
&lt;p&gt;For example, if I want to add a method to &lt;code&gt;ICarElement&lt;/code&gt; and its implementations, &lt;code&gt;Wheel&lt;/code&gt;, &lt;code&gt;Engine&lt;/code&gt; and &lt;code&gt;Body&lt;/code&gt;, I could write such a class as a set of functions:&lt;br&gt;
    
    </summary>
    
    
      <category term="Design Patterns" scheme="http://yoursite.com/tags/Design-Patterns/"/>
    
  </entry>
  
  <entry>
    <title>重探Loader（二）</title>
    <link href="http://yoursite.com/2016/02/13/review-loaders-2/"/>
    <id>http://yoursite.com/2016/02/13/review-loaders-2/</id>
    <published>2016-02-13T13:58:48.000Z</published>
    <updated>2016-02-27T07:41:24.134Z</updated>
    
    <content type="html">&lt;h1 id=&quot;过去&quot;&gt;&lt;a href=&quot;#过去&quot; class=&quot;headerlink&quot; title=&quot;过去&quot;&gt;&lt;/a&gt;过去&lt;/h1&gt;&lt;p&gt;在安卓3.0前，很多应用经常出现无法响应的bug。最主要的原因，便是在UI线程执行查询或加载数据。虽然文档一直强调即使回馈的重要性，之前的API并不鼓励这样的行为。过去通常使用activity的方法以管理Cursor。而且这些方法在UI线程中操作，并不跨越配置变更。&lt;/p&gt;
&lt;h1 id=&quot;理解LoaderManager&quot;&gt;&lt;a href=&quot;#理解LoaderManager&quot; class=&quot;headerlink&quot; title=&quot;理解LoaderManager&quot;&gt;&lt;/a&gt;理解LoaderManager&lt;/h1&gt;&lt;p&gt;LoaderManager的一些事件会有activity或fragment的生命周期事件触发。比如activity销毁时，会通知LoaderManager销毁并关闭所有所有Loader。&lt;/p&gt;
&lt;p&gt;LoaderManager不知道也不需要知道数据如何载入。它只是告诉Loader何时开始、结束或复位加载，保持状态通过配置变更，并提供简单的接口为客户端传送结果。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Loader基础&quot;&gt;&lt;a href=&quot;#Loader基础&quot; class=&quot;headerlink&quot; title=&quot;Loader基础&quot;&gt;&lt;/a&gt;Loader基础&lt;/h1&gt;&lt;p&gt;Loader负责在单独的线程中执行查询，监视数据源的变化，并且发送新的结果到注册的侦听器（一般是LoaderManager）。这使得Loader非常强大，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Loader封装了数据加载的过程。activity或fragment不再需要知道如何加载数据，他们将任务委托给了Loader，后者在幕后执行请求并发回数据。&lt;/li&gt;
&lt;li&gt;他们将线程剥离出客户端。activity或fragment不需要担心新线程中执行操作的问题，因为Loader会自动处理。这减少了代码的复杂性和可能的线程相关的bug。&lt;/li&gt;
&lt;li&gt;他们是事件驱动的。Loader监视着数据源并在变化发生时自动执行新的加载。这使得使用Loader工作非常容易，因为客户端可以简单地信任Loader会自动更新数据。所有activity或fragment要做的只是初始化Loader并且根据可能获取的数据进行响应。这之间所有的事物都由Loader完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;什么组成了Loader&quot;&gt;&lt;a href=&quot;#什么组成了Loader&quot; class=&quot;headerlink&quot; title=&quot;什么组成了Loader&quot;&gt;&lt;/a&gt;什么组成了Loader&lt;/h1&gt;&lt;p&gt;下面四个特性最终决定了Loader的行为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个执行异步加载的任务。为了保证载入过程在单独线程中执行，子类应该继承&lt;code&gt;AsyncTaskLoader&lt;/code&gt;而非&lt;code&gt;Loader&lt;/code&gt;类。&lt;code&gt;AsyncTaskLoader&lt;/code&gt;类提供了一个&lt;code&gt;AsyncTask&lt;/code&gt;来执行任务。被继承后，只需要实现抽象的&lt;code&gt;loadInBackground()&lt;/code&gt;方法来实现异步任务。该方法将在一个工作线程中被调用以执行数据加载。&lt;/li&gt;
&lt;li&gt;一个注册的监听器，用以接收载入的结果。对每个Loader，LoaderManager会注册一个&lt;code&gt;OnLoadCompleteListener&lt;/code&gt;来将Loader传送的结果通过调用&lt;code&gt;onLoadFinished()&lt;/code&gt;转发到客户端。Loader应该调用&lt;code&gt;deliverResult()&lt;/code&gt;方法将结果发送给注册的侦听器。&lt;/li&gt;
&lt;li&gt;三种状态中的一个。每个Loader只有启动、停止或复位三种状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;只有启动状态下，&lt;code&gt;onLoadFinished()&lt;/code&gt;方法会被调用。&lt;/li&gt;
&lt;li&gt;停止状态下，Loader继续监视变化，但不会返回结果。可以被启动或复位。&lt;/li&gt;
&lt;li&gt;复位状态下，不应该执行新的加载，也不应传送新的结果，不应该监视变化。进入复位状态后，应该释放并无效化所有关联的数据，使之可以被gc回收（同样，客户端应该保证移除数据的所有引用，应该会无法使用）。一般，复位的Loader不会被再次调用，然而一些情况下，可能会被再次启动。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;一个接收数据变化通知的观测者。Loader应该实现某种观测者，比如&lt;code&gt;BroadcastReceiver&lt;/code&gt;等等，来监视数据源的变化。一旦侦测到变化，观测者应该调用&lt;code&gt;Loader#onContentChanged()&lt;/code&gt;方法，如果Loader处在启动状态，强制进行一次新的加载；否则产生一个flag来表示有新的变化，这样一旦Loader再次启动就会重新载入数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;实现Loader&quot;&gt;&lt;a href=&quot;#实现Loader&quot; class=&quot;headerlink&quot; title=&quot;实现Loader&quot;&gt;&lt;/a&gt;实现Loader&lt;/h1&gt;&lt;p&gt;在实现自己的Loader时，有很多问题必须谨记。子类必须实现&lt;code&gt;loadInBackground()&lt;/code&gt;方法并重写&lt;code&gt;onStartLoading()&lt;/code&gt;, &lt;code&gt;onStopLoading()&lt;/code&gt;, &lt;code&gt;onReset()&lt;/code&gt;, &lt;code&gt;onCanceled()&lt;/code&gt;, and &lt;code&gt;deliverResult(D results)&lt;/code&gt;来实现一个完全工作的Loader。重写这些方法非常重要，因为LoaderManager会根据activity或fragment的状态来调用他们。比如，启动activity后，会在&lt;code&gt;activity#onStart()&lt;/code&gt;方法中告知LoaderManager启动所有Loader。如果Loader未被启动，LoaderManager调用&lt;code&gt;startLoading()&lt;/code&gt;，使得Loader进入启动状态，并立即调用其&lt;code&gt;onStartLoading()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;59&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;60&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;61&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;62&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;63&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;65&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;66&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;67&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;68&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;69&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;70&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;71&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;72&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;73&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;74&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;75&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;76&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;77&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;78&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;79&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;81&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;82&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;84&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;85&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;86&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;90&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;91&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;93&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;94&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;96&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;101&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;102&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;103&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;104&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;106&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;107&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;108&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;109&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;110&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;111&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;112&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;113&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;114&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;115&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;116&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;117&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;118&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;119&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;120&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;121&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;122&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;123&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;124&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;125&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;126&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;127&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;128&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;129&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;130&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;131&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;132&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;133&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;134&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;135&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleLoader&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;AsyncTaskLoader&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;List&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;SampleItem&lt;/span&gt;&amp;gt;&amp;gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 在这里保持Loader数据的引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; List&amp;lt;SampleItem&amp;gt; mData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SampleLoader&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Context ctx)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Loader可以跨越多个activity使用（假如没有绑定到LoaderManager），所以不要直接保持context的引用。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这会导致泄露整个activity的context。父类的构造器会存储一个Application Context的引用&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 可以通过getContext()方法获取&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(ctx);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/****************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/** (1) 执行异步加载的任务 **/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/****************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;SampleItem&amp;gt; &lt;span class=&quot;title&quot;&gt;loadInBackground&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 该方法在后台线程创建并产生新的数据的集合，传送给客户端&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;SampleItem&amp;gt; data = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;SampleItem&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// &lt;span class=&quot;doctag&quot;&gt;TODO:&lt;/span&gt; 在这里执行查询，并将结果添加至data&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/********************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/** (2) 将结果传送给注册的侦听器 **/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/********************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;deliverResult&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;SampleItem&amp;gt; data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isReset()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// Loader已被复位; 无视结果，并将数据无效化.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      releaseResources(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保持旧数据的引用，使之不被gc回收。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 保护它直到新数据被送达.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    List&amp;lt;SampleItem&amp;gt; oLoaderData = mData;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mData = data;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (isStarted()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 若Loader已启动，传送结果至客户端。父类方法会实现具体的操作。&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.deliverResult(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 将已经不需要的旧数据无效化.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (oLoaderData != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; oLoaderData != data) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      releaseResources(oLoaderData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/*********************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/** (3) 实现Loader状态依赖的行为 **/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/*********************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStartLoading&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mData != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 立即传送先前载入的数据.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      deliverResult(mData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 监视数据源.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mObserver == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mObserver = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SampleObserver();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// &lt;span class=&quot;doctag&quot;&gt;TODO:&lt;/span&gt; 注册观测者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (takeContentChanged() || mData == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 观测者发现变化后，应调用loader的onContentChanged()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 后者会造成下次调用takeContentChanged()返回true&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// 这种情况下（或当前数据为null），会强制一次新的加载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      forceLoad();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onStopLoading&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 在停止状态下，应该试着取消当前的载入（如果有的话）&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    cancelLoad();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 注意我们没有变更观测者. 停止状态下的Loaders仍然应该监视数据源的变化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这样Loader再次启动后会知道是否需要强制进行新的加载&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onReset&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 确保loader已被停止.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    onStopLoading();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 这里我们可以释放与&#39;mData&#39;关联的资源.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mData != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      releaseResources(mData);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mData = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 如果loader正在被复位，应该停止监视数据变化.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (mObserver != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;comment&quot;&gt;// &lt;span class=&quot;doctag&quot;&gt;TODO:&lt;/span&gt; 注销观测者&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      mObserver = &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCanceled&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;SampleItem&amp;gt; data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 试着取消当前的异步加载.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onCanceled(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 加载已取消，应该释放&#39;data&#39;相关的资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    releaseResources(data);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;releaseResources&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(List&amp;lt;SampleItem&amp;gt; data)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 对简单的列表，不需要做任何事。对Cursor，应该在这里进行关闭。所有Loader相关的资源&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 应该在这里释放&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/*********************************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/** (4) 接收数据变化通知的观测者 **/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;/*********************************************************************/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// &lt;span class=&quot;doctag&quot;&gt;NOTE:&lt;/span&gt; Implementing an observer is outside the scope of this post (this example&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// uses a made-up &quot;SampleObserver&quot; to illustrate when/where the observer shouLoader &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// be initialized). &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 观测者只需要能够探测到数据源的变化并通过调用onContentChanged()报告给Loader&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 如果在写载入设备上所有应用的列表的Loader的话，观测者应该是一个侦听&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// ACTION_PACKAGE_ADDED intent的BroadcastReceiver，并且探测到新应用安装时，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;// 调用特定Loader的onContentChanged() 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; SampleObserver mObserver;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;过去&quot;&gt;&lt;a href=&quot;#过去&quot; class=&quot;headerlink&quot; title=&quot;过去&quot;&gt;&lt;/a&gt;过去&lt;/h1&gt;&lt;p&gt;在安卓3.0前，很多应用经常出现无法响应的bug。最主要的原因，便是在UI线程执行查询或加载数据。虽然文档一直强调即使回馈的重要性，之前的API并不鼓励这样的行为。过去通常使用activity的方法以管理Cursor。而且这些方法在UI线程中操作，并不跨越配置变更。&lt;/p&gt;
&lt;h1 id=&quot;理解LoaderManager&quot;&gt;&lt;a href=&quot;#理解LoaderManager&quot; class=&quot;headerlink&quot; title=&quot;理解LoaderManager&quot;&gt;&lt;/a&gt;理解LoaderManager&lt;/h1&gt;&lt;p&gt;LoaderManager的一些事件会有activity或fragment的生命周期事件触发。比如activity销毁时，会通知LoaderManager销毁并关闭所有所有Loader。&lt;/p&gt;
&lt;p&gt;LoaderManager不知道也不需要知道数据如何载入。它只是告诉Loader何时开始、结束或复位加载，保持状态通过配置变更，并提供简单的接口为客户端传送结果。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Loader" scheme="http://yoursite.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>重探Loader（一）</title>
    <link href="http://yoursite.com/2016/02/13/review-loaders/"/>
    <id>http://yoursite.com/2016/02/13/review-loaders/</id>
    <published>2016-02-13T12:52:41.000Z</published>
    <updated>2016-02-14T17:11:12.388Z</updated>
    
    <content type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Loader是安卓中非常好用的一个pattern，也是我个人非常喜欢用的一个。Loader最方便之处，就是免除了手动保存数据之苦。但在长期的使用之中，总觉得对loader的理解还是存在一些偏差。所以，这里重新复习一下loader的基本知识。&lt;/p&gt;
&lt;p&gt;Loader自安卓3.0引入，它的出现使得在activity或fragment中异步载入数据更加容易，有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个activity或fragment都可使用&lt;/li&gt;
&lt;li&gt;异步载入数据&lt;/li&gt;
&lt;li&gt;监视数据源的变化，并获取新的数据&lt;/li&gt;
&lt;li&gt;配置变更后自动重连之前的loader cursor。无需重新获取数据&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;Loader-API-总结&quot;&gt;&lt;a href=&quot;#Loader-API-总结&quot; class=&quot;headerlink&quot; title=&quot;Loader API 总结&quot;&gt;&lt;/a&gt;Loader API 总结&lt;/h1&gt;LoaderMangager: activity或fragment关联的抽象类，可管理一个或多个Loader。使应用管理与生命周期相关的长期操作，最常用的是&lt;code&gt;CursorLoader&lt;/code&gt;，不过应用可以任意创建载入其他类型的Loader。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LoaderManager.LoaderCallbacks: 与LoaderManager交互的回调接口。&lt;/p&gt;
&lt;p&gt;Loader: 执行异步加载数据的抽象类。是Loader的基类。一般使用CursorLoader，但也可以实现自己的子类。当loader活动时，应该监视数据源的变化并获取新的结果。&lt;/p&gt;
&lt;p&gt;AsyncTaskLoader: 提供了&lt;code&gt;AsyncTask&lt;/code&gt;来执行任务的抽象Loader。&lt;/p&gt;
&lt;p&gt;CursorLoader: &lt;code&gt;AsyncTaskLoader&lt;/code&gt;的子类，查询&lt;code&gt;ContentResolver&lt;/code&gt;，返回&lt;code&gt;Cursor&lt;/code&gt;。这个类以标准的方式实现了Loader协议以查询cursor，继承&lt;code&gt;AsyncTaskLoader&lt;/code&gt;以在后台线程执行查询，避免阻碍应用UI。使用这个Loader是从Content Provider中异步载入数据的最好方式，而非通过fragment或activity的API来执行查询。&lt;/p&gt;
&lt;h1 id=&quot;在应用中使用Loader&quot;&gt;&lt;a href=&quot;#在应用中使用Loader&quot; class=&quot;headerlink&quot; title=&quot;在应用中使用Loader&quot;&gt;&lt;/a&gt;在应用中使用Loader&lt;/h1&gt;&lt;h2 id=&quot;启动Loader&quot;&gt;&lt;a href=&quot;#启动Loader&quot; class=&quot;headerlink&quot; title=&quot;启动Loader&quot;&gt;&lt;/a&gt;启动Loader&lt;/h2&gt;&lt;p&gt;在activity或fragment中LoaderManager管理着一个或多个Loader实例，每个activity或fragment中只有一个LoaderManager。&lt;/p&gt;
&lt;p&gt;一般在activity的&lt;code&gt;onCreate()&lt;/code&gt;或fragment的&lt;code&gt;onactivityCreated()&lt;/code&gt;方法初始化Loader。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Prepare the loader.  Either re-connect with an existing one,
// or start a new one.
getLoaderManager().initLoader(0, null, this);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;initLoader()&lt;/code&gt;方法需要以下参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个独特的ID，如0.&lt;/li&gt;
&lt;li&gt;提供给Loader用以创建的额外参数，如null。&lt;/li&gt;
&lt;li&gt;一个&lt;code&gt;LoaderManager.LoaderCallbacks&lt;/code&gt;实现，LoaderManager调用其以报告Loader事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;调用&lt;code&gt;initLoader()&lt;/code&gt;方法保证一个loader被初始化并且活跃，它有两个可能的结果：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果该ID已经存在，重用上次创建的Loader。&lt;/li&gt;
&lt;li&gt;否则，调用回调接口中的&lt;code&gt;onCreateLoader()&lt;/code&gt;。在这里实现初始化新loader的代码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意，&lt;code&gt;initLoader()&lt;/code&gt;方法返回创建的Loader，但是你不必去保存其引用。LoaderManager自动管理Loader的生命。LoaderManager在需要时启动和终止载入，并维护Loader的状态和关联的内容。这意味着，一般不需要与Loader直接交互。一般使用回调方法在特定事件发生时干预加载进程。&lt;/p&gt;
&lt;h2 id=&quot;重启Loader&quot;&gt;&lt;a href=&quot;#重启Loader&quot; class=&quot;headerlink&quot; title=&quot;重启Loader&quot;&gt;&lt;/a&gt;重启Loader&lt;/h2&gt;&lt;p&gt;有时我们需要丢弃旧数据，重新启动Loader。要丢弃旧数据，调用&lt;code&gt;restartLoader()&lt;/code&gt;方法。例如，&lt;code&gt;SearchView.OnQueryTextListener&lt;/code&gt;的实现在用户改变查询时重启Loader。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public boolean onQueryTextChanged(String newText) {
    // Called when the ACTION bar search text has changed.  Update
    // the search filter, and restart the loader to do a new query
    // with this filter.
    mCurFilter = !TextUtils.isEmpty(newText) ? newText : null;
    getLoaderManager().restartLoader(0, null, this);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用LoaderManager回调&quot;&gt;&lt;a href=&quot;#使用LoaderManager回调&quot; class=&quot;headerlink&quot; title=&quot;使用LoaderManager回调&quot;&gt;&lt;/a&gt;使用LoaderManager回调&lt;/h2&gt;&lt;p&gt;Loader，尤其是CursorLoader，一般会在停止后保留数据。这使得应用可以跨越activity或fragment的&lt;code&gt;onStop()&lt;/code&gt;和&lt;code&gt;onStart()&lt;/code&gt;方法保留数据。当用户返回应用时，无需等待数据重新载入。&lt;/p&gt;
&lt;h3 id=&quot;onCreateLoader&quot;&gt;&lt;a href=&quot;#onCreateLoader&quot; class=&quot;headerlink&quot; title=&quot;onCreateLoader&quot;&gt;&lt;/a&gt;onCreateLoader&lt;/h3&gt;&lt;p&gt;访问loader时，首先检查该id是否存在。如果不存在，调用&lt;code&gt;onCreateLoader()&lt;/code&gt;方法，在这里创建新的Loader。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; // If non-null, this is the current filter the user has provided.
String mCurFilter;
...
public Loader&amp;lt;Cursor&amp;gt; onCreateLoader(int id, Bundle args) {
    // This is called when a new Loader needs to be created.  This
    // sample only has one Loader, so we don&amp;apos;t care about the ID.
    // First, pick the base URI to use depending on whether we are
    // currently filtering.
    Uri baseUri;
    if (mCurFilter != null) {
        baseUri = Uri.withAppendedPath(Contactivitys.CONTENT_FILTER_URI,
                  Uri.encode(mCurFilter));
    } else {
        baseUri = Contactivitys.CONTENT_URI;
    }

    // Now create and return a CursorLoader that will take care of
    // creating a Cursor for the data being displayed.
    String select = &amp;quot;((&amp;quot; + Contactivitys.DISPLAY_NAME + &amp;quot; NOTNULL) AND (&amp;quot;
            + Contactivitys.HAS_PHONE_NUMBER + &amp;quot;=1) AND (&amp;quot;
            + Contactivitys.DISPLAY_NAME + &amp;quot; != &amp;apos;&amp;apos; ))&amp;quot;;
    return new CursorLoader(getactivity(), baseUri,
            CONTactivityS_SUMMARY_PROJECTION, select, null,
            Contactivitys.DISPLAY_NAME + &amp;quot; COLLATE LOCALIZED ASC&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;onLoadFinished&quot;&gt;&lt;a href=&quot;#onLoadFinished&quot; class=&quot;headerlink&quot; title=&quot;onLoadFinished&quot;&gt;&lt;/a&gt;onLoadFinished&lt;/h3&gt;&lt;p&gt;当Loader完成一次加载后调用该方法。这个方法保证了在旧数据被释放前调用。在这一点，应该移除所有旧数据的使用（因为马上会被释放），但是不应该自己释放数据，因为Loader拥有并管理它。&lt;/p&gt;
&lt;p&gt;一旦获知应用不再使用数据，Loader就会将其释放。例如，如果数据是CursorLoader中获取的cursor，不要手动调用&lt;code&gt;CursorLoaderose()&lt;/code&gt;。如果cursor被放置在一个&lt;code&gt;CursorAdapter&lt;/code&gt;中，应该使用&lt;code&gt;swapCursor()&lt;/code&gt;方法，而旧&lt;code&gt;Cursor&lt;/code&gt;不被关闭。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// This is the Adapter being used to display the list&amp;apos;s data.
SimpleCursorAdapter mAdapter;
...

public void onLoadFinished(Loader&amp;lt;Cursor&amp;gt; loader, Cursor data) {
    // Swap the new cursor in.  (The framework will take care of CursorLoaderosing the
    // oLoader cursor once we return.)
    mAdapter.swapCursor(data);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;onLoaderReset&quot;&gt;&lt;a href=&quot;#onLoaderReset&quot; class=&quot;headerlink&quot; title=&quot;onLoaderReset&quot;&gt;&lt;/a&gt;onLoaderReset&lt;/h3&gt;&lt;p&gt;当复位原来创建的Loader时调用，使原数据无效。这个回调告知你数据将被释放，所以可以在此时移除对其的引用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// This is the Adapter being used to display the list&amp;apos;s data.
SimpleCursorAdapter mAdapter;
...

public void onLoaderReset(Loader&amp;lt;Cursor&amp;gt; loader) {
    // This is called when the last Cursor provided to onLoadFinished()
    // above is about to be CursorLoaderosed.  We need to make sure we are no
    // longer using it.
    mAdapter.swapCursor(null);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;例子&quot;&gt;&lt;a href=&quot;#例子&quot; class=&quot;headerlink&quot; title=&quot;例子&quot;&gt;&lt;/a&gt;例子&lt;/h1&gt;&lt;p&gt;下面是一个fragment的完整实现，它展示了一个&lt;code&gt;ListView&lt;/code&gt;，包含着联系人的查询结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static class CursorLoaderListFragment extends ListFragment
        implements OnQueryTextListener, LoaderManager.LoaderCallbacks&amp;lt;Cursor&amp;gt; {

    // This is the Adapter being used to display the list&amp;apos;s data.
    SimpleCursorAdapter mAdapter;

    // If non-null, this is the current filter the user has provided.
    String mCurFilter;

    @Override public void onActivityCreated(Bundle savedInstanceState) {
        super.onActivityCreated(savedInstanceState);

        // Give some text to display if there is no data.  In a real
        // application this would come from a resource.
        setEmptyText(&amp;quot;No phone numbers&amp;quot;);

        // We have a menu item to show in action bar.
        setHasOptionsMenu(true);

        // Create an empty adapter we will use to display the loaded data.
        mAdapter = new SimpleCursorAdapter(getActivity(),
                android.R.layout.simple_list_item_2, null,
                new String[] { Contacts.DISPLAY_NAME, Contacts.CONTACT_STATUS },
                new int[] { android.R.id.text1, android.R.id.text2 }, 0);
        setListAdapter(mAdapter);

        // Prepare the loader.  Either re-connect with an existing one,
        // or start a new one.
        getLoaderManager().initLoader(0, null, this);
    }

    @Override public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
        // Place an action bar item for searching.
        MenuItem item = menu.add(&amp;quot;Search&amp;quot;);
        item.setIcon(android.R.drawable.ic_menu_search);
        item.setShowAsAction(MenuItem.SHOW_AS_ACTION_IF_ROOM);
        SearchView sv = new SearchView(getActivity());
        sv.setOnQueryTextListener(this);
        item.setActionView(sv);
    }

    public boolean onQueryTextChange(String newText) {
        // Called when the action bar search text has changed.  Update
        // the search filter, and restart the loader to do a new query
        // with this filter.
        mCurFilter = !TextUtils.isEmpty(newText) ? newText : null;
        getLoaderManager().restartLoader(0, null, this);
        return true;
    }

    @Override public boolean onQueryTextSubmit(String query) {
        // Don&amp;apos;t care about this.
        return true;
    }

    @Override public void onListItemClick(ListView l, View v, int position, long id) {
        // Insert desired behavior here.
        Log.i(&amp;quot;FragmentComplexList&amp;quot;, &amp;quot;Item clicked: &amp;quot; + id);
    }

    // These are the Contacts rows that we will retrieve.
    static final String[] CONTACTS_SUMMARY_PROJECTION = new String[] {
        Contacts._ID,
        Contacts.DISPLAY_NAME,
        Contacts.CONTACT_STATUS,
        Contacts.CONTACT_PRESENCE,
        Contacts.PHOTO_ID,
        Contacts.LOOKUP_KEY,
    };
    public Loader&amp;lt;Cursor&amp;gt; onCreateLoader(int id, Bundle args) {
        // This is called when a new Loader needs to be created.  This
        // sample only has one Loader, so we don&amp;apos;t care about the ID.
        // First, pick the base URI to use depending on whether we are
        // currently filtering.
        Uri baseUri;
        if (mCurFilter != null) {
            baseUri = Uri.withAppendedPath(Contacts.CONTENT_FILTER_URI,
                    Uri.encode(mCurFilter));
        } else {
            baseUri = Contacts.CONTENT_URI;
        }

        // Now create and return a CursorLoader that will take care of
        // creating a Cursor for the data being displayed.
        String select = &amp;quot;((&amp;quot; + Contacts.DISPLAY_NAME + &amp;quot; NOTNULL) AND (&amp;quot;
                + Contacts.HAS_PHONE_NUMBER + &amp;quot;=1) AND (&amp;quot;
                + Contacts.DISPLAY_NAME + &amp;quot; != &amp;apos;&amp;apos; ))&amp;quot;;
        return new CursorLoader(getActivity(), baseUri,
                CONTACTS_SUMMARY_PROJECTION, select, null,
                Contacts.DISPLAY_NAME + &amp;quot; COLLATE LOCALIZED ASC&amp;quot;);
    }

    public void onLoadFinished(Loader&amp;lt;Cursor&amp;gt; loader, Cursor data) {
        // Swap the new cursor in.  (The framework will take care of closing the
        // old cursor once we return.)
        mAdapter.swapCursor(data);
    }

    public void onLoaderReset(Loader&amp;lt;Cursor&amp;gt; loader) {
        // This is called when the last Cursor provided to onLoadFinished()
        // above is about to be closed.  We need to make sure we are no
        // longer using it.
        mAdapter.swapCursor(null);
    }
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Loader是安卓中非常好用的一个pattern，也是我个人非常喜欢用的一个。Loader最方便之处，就是免除了手动保存数据之苦。但在长期的使用之中，总觉得对loader的理解还是存在一些偏差。所以，这里重新复习一下loader的基本知识。&lt;/p&gt;
&lt;p&gt;Loader自安卓3.0引入，它的出现使得在activity或fragment中异步载入数据更加容易，有以下特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个activity或fragment都可使用&lt;/li&gt;
&lt;li&gt;异步载入数据&lt;/li&gt;
&lt;li&gt;监视数据源的变化，并获取新的数据&lt;/li&gt;
&lt;li&gt;配置变更后自动重连之前的loader cursor。无需重新获取数据
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Loader" scheme="http://yoursite.com/tags/Loader/"/>
    
  </entry>
  
  <entry>
    <title>使用Preferences API（二）</title>
    <link href="http://yoursite.com/2016/02/05/learning-preferences-2/"/>
    <id>http://yoursite.com/2016/02/05/learning-preferences-2/</id>
    <published>2016-02-05T10:48:59.000Z</published>
    <updated>2016-02-05T10:49:44.623Z</updated>
    
    <content type="html">&lt;h1 id=&quot;使用pref-header&quot;&gt;&lt;a href=&quot;#使用pref-header&quot; class=&quot;headerlink&quot; title=&quot;使用pref header&quot;&gt;&lt;/a&gt;使用pref header&lt;/h1&gt;&lt;p&gt;某些情况下，可能需要设计设置页面来使第一个屏幕展示一列子屏幕。在3.0以上版本中，应该使用新的header特性，而非使用嵌套的&lt;code&gt;PreferenceScreen&lt;/code&gt;元素。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分离各组设置至不同的PF实例。每组设置需要单独的XML文件。&lt;/li&gt;
&lt;li&gt;创建XML header文件，列出每个设置组，声明含有对应设置列表的fragment。&lt;/li&gt;
&lt;li&gt;继承PA类来持有设置。&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;onBuildHeaderes()&lt;/code&gt;回调来指定header文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样做的一个好处是，PA可以自动在大屏幕中使用双面板布局呈现设定。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建header文件&quot;&gt;&lt;a href=&quot;#创建header文件&quot; class=&quot;headerlink&quot; title=&quot;创建header文件&quot;&gt;&lt;/a&gt;创建header文件&lt;/h2&gt;&lt;p&gt;在header列表中，各组设定由根&lt;code&gt;&amp;lt;preference-headers&amp;gt;&lt;/code&gt;中单个&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;元素指定。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;preference-headers xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
    &amp;lt;header 
        android:fragment=&amp;quot;com.example.prefs.SettingsActivity$SettingsFragmentOne&amp;quot;
        android:title=&amp;quot;@string/prefs_category_one&amp;quot;
        android:summary=&amp;quot;@string/prefs_summ_category_one&amp;quot; /&amp;gt;
    &amp;lt;header 
        android:fragment=&amp;quot;com.example.prefs.SettingsActivity$SettingsFragmentTwo&amp;quot;
        android:title=&amp;quot;@string/prefs_category_two&amp;quot;
        android:summary=&amp;quot;@string/prefs_summ_category_two&amp;quot; &amp;gt;
        &amp;lt;!-- key/value pairs can be included as arguments for the fragment. --&amp;gt;
        &amp;lt;extra android:name=&amp;quot;someKey&amp;quot; android:value=&amp;quot;someHeaderValue&amp;quot; /&amp;gt;
    &amp;lt;/header&amp;gt;
&amp;lt;/preference-headers&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;通过&lt;code&gt;android:fragment&lt;/code&gt;属性，每个header声明一个用户选择时应该打开的PF实例。&lt;/p&gt;
&lt;p&gt;&lt;extras&gt;元素可以用&lt;code&gt;Bundle&lt;/code&gt;将键值对传入fragment中。Fragment可以调用&lt;code&gt;getArguments()&lt;/code&gt;方法来获取参数。将参数传入fragment可能有很多原因，但其中比较好的一个原因是，可以使每一组设定重用同样的PF子类，并使用参数来指定应该加载的pref XML。&lt;/extras&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static class SettingsFragment extends PreferenceFragment {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        String settings = getArguments().getString(&amp;quot;settings&amp;quot;);
        if (&amp;quot;notifications&amp;quot;.equals(settings)) {
            addPreferencesFromResource(R.xml.settings_wifi);
        } else if (&amp;quot;sync&amp;quot;.equals(settings)) {
            addPreferencesFromResource(R.xml.settings_sync);
        }
    }
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;显示header&quot;&gt;&lt;a href=&quot;#显示header&quot; class=&quot;headerlink&quot; title=&quot;显示header&quot;&gt;&lt;/a&gt;显示header&lt;/h2&gt;&lt;p&gt;要显示pref header，必须实现&lt;code&gt;onBuildHeader()&lt;/code&gt;回调，并调用&lt;code&gt;loadHeadersFromResources()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SettingsActivity extends PreferenceActivity {
    @Override
    public void onBuildHeaders(List&amp;lt;Header&amp;gt; target) {
        loadHeadersFromResource(R.xml.preference_headers, target);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当用户选择一个列表中的一个子项时，系统打开相应的PF。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用pref header时，PA的子类无需实现&lt;code&gt;onCreate()&lt;/code&gt;方法，因为ACT唯一需要的任务只是加载header。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;读取Pref&quot;&gt;&lt;a href=&quot;#读取Pref&quot; class=&quot;headerlink&quot; title=&quot;读取Pref&quot;&gt;&lt;/a&gt;读取Pref&lt;/h1&gt;&lt;p&gt;默认情况下，应用的所有pref都存在一个文件中，它可以在应用的任何地方通过调用静态方法&lt;code&gt;PreferenceManager.getDefaultSharedPreferences()&lt;/code&gt;来访问，并返回包含PA中所有pref对象相应的键值对的SP对象。&lt;/p&gt;
&lt;p&gt;例如，下面是在某个ACT中读取一条pref值的代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(this);
String syncConnPref = sharedPref.getString(SettingsActivity.KEY_PREF_SYNC_CONN, &amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;侦听pref变化&quot;&gt;&lt;a href=&quot;#侦听pref变化&quot; class=&quot;headerlink&quot; title=&quot;侦听pref变化&quot;&gt;&lt;/a&gt;侦听pref变化&lt;/h2&gt;&lt;p&gt;有时候需要在用户改变pref时马上得到通知。为了获取一个pref发生变化的回调，实现&lt;code&gt;SharedPreference.OnSharedPreferenceChangeListener&lt;/code&gt;接口，并且通过&lt;code&gt;registerOnSharedPreferenceChangeListener()&lt;/code&gt;注册到SP对象中。&lt;/p&gt;
&lt;p&gt;接口仅仅拥有一个回调方法，&lt;code&gt;onSharedPreferenceChanged()&lt;/code&gt;，最简单的是将其实现成为ACT的一部分：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SettingsActivity extends PreferenceActivity
                              implements OnSharedPreferenceChangeListener {
    public static final String KEY_PREF_SYNC_CONN = &amp;quot;pref_syncConnectionType&amp;quot;;
    ...

    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
        String key) {
        if (key.equals(KEY_PREF_SYNC_CONN)) {
            Preference connectionPref = findPreference(key);
            // Set summary to be the user-description for the selected value
            connectionPref.setSummary(sharedPreferences.getString(key, &amp;quot;&amp;quot;));
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在这个例子中这个方法检查变化的设定是否为某个pref key。它调用&lt;code&gt;findPreference()&lt;/code&gt;方法来获取改变的&lt;code&gt;Preference&lt;/code&gt;对象，并可以将其summary替换成用户的选择。就是说，当设定是&lt;code&gt;ListPreference&lt;/code&gt;或其他多选设定时，应该调用&lt;code&gt;setSummary()&lt;/code&gt;方法来展示当前的状态。&lt;/p&gt;
&lt;p&gt;为了ACT中合适的生命周期管理，建议在&lt;code&gt;onResume()&lt;/code&gt;和&lt;code&gt;onPause()&lt;/code&gt;回调中注册和注销&lt;code&gt;SharedPreferences.OnSharedPreferenceChangeListener&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
protected void onResume() {
    super.onResume();
    getPreferenceScreen().getSharedPreferences()
            .registerOnSharedPreferenceChangeListener(this);
}

@Override
protected void onPause() {
    super.onPause();
    getPreferenceScreen().getSharedPreferences()
            .unregisterOnSharedPreferenceChangeListener(this);
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意：调用注册方法时，pref manager不会储存一个侦听器的强引用。必须手动储存一个侦听器的强引用，否则将可能被gc回收。建议在一个存活时间与侦听器相同的某个实例中保持侦听器的引用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;例如在下面的代码中，调用者不持有侦听器的引用。这会导致侦听器可能被gc回收，并在未来某个时候导致崩溃。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;prefs.registerOnSharedPreferenceChangeListener(
  // Bad! The listener is subject to garbage collection!
  new SharedPreferences.OnSharedPreferenceChangeListener() {
  public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
    // listener implementation
  }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在实例的field中存储侦听器的引用可以保持侦听器的实例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SharedPreferences.OnSharedPreferenceChangeListener listener =
    new SharedPreferences.OnSharedPreferenceChangeListener() {
  public void onSharedPreferenceChanged(SharedPreferences prefs, String key) {
    // listener implementation
  }
};
prefs.registerOnSharedPreferenceChangeListener(listener);
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;管理网络使用&quot;&gt;&lt;a href=&quot;#管理网络使用&quot; class=&quot;headerlink&quot; title=&quot;管理网络使用&quot;&gt;&lt;/a&gt;管理网络使用&lt;/h1&gt;&lt;p&gt;安卓4.0以后，系统的设置应用可以允许用户查看应用在前台和后台使用的数据流量大小。用户可以禁止应用的后台数据。为了避免用户禁止后台的数据访问，应该允许用户在设定中修订应用的数据使用方式。&lt;/p&gt;
&lt;p&gt;例如，可以允许用户控制应用同步数据的周期，是否仅在wifi下上传下载数据，是否在漫游时使用数据。如果可以控制这些设定，用户可能不会再系统设定中关闭数据访问。&lt;/p&gt;
&lt;p&gt;在PA中添加了这些控制数据行为的pref后，应该在manifest中添加一个&lt;code&gt;ACTION_MANAGE_NETWORK_USAGE&lt;/code&gt;的intent filter.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;activity android:name=&amp;quot;SettingsActivity&amp;quot; ... &amp;gt;
    &amp;lt;intent-filter&amp;gt;
       &amp;lt;action android:name=&amp;quot;android.intent.action.MANAGE_NETWORK_USAGE&amp;quot; /&amp;gt;
       &amp;lt;category android:name=&amp;quot;android.intent.category.DEFAULT&amp;quot; /&amp;gt;
    &amp;lt;/intent-filter&amp;gt;
&amp;lt;/activity&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个intent filter告诉系统这个ACT可以控制应用的数据使用。因而，用户在系统设定应用中查看应用的数据流量时，可以通过一个按钮打开该PA，具体设定使用方式。&lt;/p&gt;
&lt;h1 id=&quot;创建自定义pref&quot;&gt;&lt;a href=&quot;#创建自定义pref&quot; class=&quot;headerlink&quot; title=&quot;创建自定义pref&quot;&gt;&lt;/a&gt;创建自定义pref&lt;/h1&gt;&lt;p&gt;略&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用pref-header&quot;&gt;&lt;a href=&quot;#使用pref-header&quot; class=&quot;headerlink&quot; title=&quot;使用pref header&quot;&gt;&lt;/a&gt;使用pref header&lt;/h1&gt;&lt;p&gt;某些情况下，可能需要设计设置页面来使第一个屏幕展示一列子屏幕。在3.0以上版本中，应该使用新的header特性，而非使用嵌套的&lt;code&gt;PreferenceScreen&lt;/code&gt;元素。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分离各组设置至不同的PF实例。每组设置需要单独的XML文件。&lt;/li&gt;
&lt;li&gt;创建XML header文件，列出每个设置组，声明含有对应设置列表的fragment。&lt;/li&gt;
&lt;li&gt;继承PA类来持有设置。&lt;/li&gt;
&lt;li&gt;实现&lt;code&gt;onBuildHeaderes()&lt;/code&gt;回调来指定header文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这样做的一个好处是，PA可以自动在大屏幕中使用双面板布局呈现设定。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>使用Preferences API（一）</title>
    <link href="http://yoursite.com/2016/02/05/learning-preferences/"/>
    <id>http://yoursite.com/2016/02/05/learning-preferences/</id>
    <published>2016-02-05T07:43:43.000Z</published>
    <updated>2016-02-05T10:48:46.616Z</updated>
    
    <content type="html">&lt;p&gt;应用一般都包含一些用户可以自定义的设置，比如是否推送通知，更新数据的频率等等。&lt;/p&gt;
&lt;p&gt;如果想要为应用提供设置，应该使用安卓的&lt;code&gt;Preference&lt;/code&gt;API来创建一致的用户体验。&lt;/p&gt;
&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;与使用&lt;code&gt;View&lt;/code&gt;创造界面不同，设置是由xml文件中声明的各种&lt;code&gt;Preference&lt;/code&gt;的子类组成。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;Preference&lt;/code&gt;对象构成一个设置。每个&lt;code&gt;Preference&lt;/code&gt;显示为列表中的一个子项，并提供合适的UI供用户交互。例如，&lt;code&gt;CheckBoxPreference&lt;/code&gt;创造一个勾选框子项，&lt;code&gt;ListPreference&lt;/code&gt;创造一个弹出选择列表对话框的子项。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Preference&lt;/code&gt;在系统使用的默认的&lt;code&gt;SharedPreferences&lt;/code&gt;文件中存在一个对应的键值对。用户更改设置后，系统在SP文件中更新相应的值。只有当需要从SP中读取值以决定应用行为时，才需要直接与SP相交互。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;存在SP中的值包含以下几种类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boolean&lt;/li&gt;
&lt;li&gt;Float&lt;/li&gt;
&lt;li&gt;Int&lt;/li&gt;
&lt;li&gt;Long&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;String &lt;code&gt;Set&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因为用户的设置UI是通过&lt;code&gt;Preference&lt;/code&gt;而非&lt;code&gt;View&lt;/code&gt;构成的，所以需要使用特殊的&lt;code&gt;Activity&lt;/code&gt;或&lt;code&gt;Fragment&lt;/code&gt;子类来展示设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果应用支持安卓3.0以前的设备，需要继承&lt;code&gt;PreferenceActivity&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在3.0以上版本，应该使用一个传统&lt;code&gt;Activity&lt;/code&gt;来加载&lt;code&gt;PreferenceFragment&lt;/code&gt;。当有多组设定时，也可以使用&lt;code&gt;PreferenceActivity&lt;/code&gt;来为大屏幕创建一个双面板的布局。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;Preference&quot;&gt;&lt;a href=&quot;#Preference&quot; class=&quot;headerlink&quot; title=&quot;Preference&quot;&gt;&lt;/a&gt;Preference&lt;/h1&gt;&lt;p&gt;应用的每个设定都由一个特定的&lt;code&gt;Pref&lt;/code&gt;子类来表示。每个子类包含一套核心属性，可以指定设定的标题和默认值等等。每个子类也提供自己特殊的属性和UI。&lt;/p&gt;
&lt;h1 id=&quot;在XML中定义属性&quot;&gt;&lt;a href=&quot;#在XML中定义属性&quot; class=&quot;headerlink&quot; title=&quot;在XML中定义属性&quot;&gt;&lt;/a&gt;在XML中定义属性&lt;/h1&gt;&lt;p&gt;虽然可以在运行时创建新的&lt;code&gt;Pref&lt;/code&gt;，但是应该在XML中定义设定的列表。使用XML的方法更好，因为文件可以提供易读的结构，也容易更新。而且，应用的设定一般都是预先设定好的，虽然可以在运行时进行修改。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Pref&lt;/code&gt;子类可以用一个匹配类名的XML元素声明，比如&lt;code&gt;&amp;lt;CheckBoxPreference&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;必须在&lt;code&gt;res/xml/&lt;/code&gt;目录下保存XML文件。虽然可以随便命名文件，但是一般都取名为&lt;code&gt;preferences.xml&lt;/code&gt;。一般只需要一个文件，因为阶层中的分支一般使用嵌套的&lt;code&gt;PreferenceScreen&lt;/code&gt;来声明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：如果想要创建多面板布局，则需要为每个fragment创建相应的XML文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;XML文件的根节点必须是一个&lt;code&gt;&amp;lt;PreferenceScreen&amp;gt;&lt;/code&gt;元素。在元素内可以添加&lt;code&gt;Pref&lt;/code&gt;。元素内每个添加的子元素都显示为设定列表的一个子项。比如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;utf-8&amp;quot;?&amp;gt;
&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
    &amp;lt;CheckBoxPreference
        android:key=&amp;quot;pref_sync&amp;quot;
        android:title=&amp;quot;@string/pref_sync&amp;quot;
        android:summary=&amp;quot;@string/pref_sync_summ&amp;quot;
        android:defaultValue=&amp;quot;true&amp;quot; /&amp;gt;
    &amp;lt;ListPreference
        android:dependency=&amp;quot;pref_sync&amp;quot;
        android:key=&amp;quot;pref_syncConnectionType&amp;quot;
        android:title=&amp;quot;@string/pref_syncConnectionType&amp;quot;
        android:dialogTitle=&amp;quot;@string/pref_syncConnectionType&amp;quot;
        android:entries=&amp;quot;@array/pref_syncConnectionTypes_entries&amp;quot;
        android:entryValues=&amp;quot;@array/pref_syncConnectionTypes_values&amp;quot;
        android:defaultValue=&amp;quot;@string/pref_syncConnectionTypes_default&amp;quot; /&amp;gt;
&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;每个子项都包含了三个特性：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:key&lt;/code&gt;：每个持有数据的pref都需要包含该特性。它为系统指明了一个独特的key字符串，以将设置存储至SP中。只有&lt;code&gt;PrefrenceCategory&lt;/code&gt;和&lt;code&gt;PreferenceScreen&lt;/code&gt;元素以及指明调用的&lt;code&gt;Intent&lt;/code&gt;或显示的&lt;code&gt;Fragment&lt;/code&gt;的元素不需要该属性。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:title&lt;/code&gt;：提供用户可见的设定名称。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:defaultValue&lt;/code&gt;：系统应在SP中设定的初始值。应该为每个设定都提供一个初始值。&lt;/p&gt;
&lt;h1 id=&quot;创建设定组&quot;&gt;&lt;a href=&quot;#创建设定组&quot; class=&quot;headerlink&quot; title=&quot;创建设定组&quot;&gt;&lt;/a&gt;创建设定组&lt;/h1&gt;&lt;p&gt;如果设定的列表超过10项，可能对用户很不友好。这时可以将他们分成几组。一组相关的设定可以用两种方式呈现出来：使用标题或使用子屏幕。&lt;/p&gt;
&lt;h2 id=&quot;使用标题&quot;&gt;&lt;a href=&quot;#使用标题&quot; class=&quot;headerlink&quot; title=&quot;使用标题&quot;&gt;&lt;/a&gt;使用标题&lt;/h2&gt;&lt;p&gt;如果想要为设定组之间提供带有标题的分隔线，可以将各组&lt;code&gt;Pref&lt;/code&gt;对象放置在&lt;code&gt;PreferenceCategory&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;PreferenceScreen xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
    &amp;lt;PreferenceCategory 
        android:title=&amp;quot;@string/pref_sms_storage_title&amp;quot;
        android:key=&amp;quot;pref_key_storage_settings&amp;quot;&amp;gt;
        &amp;lt;CheckBoxPreference
            android:key=&amp;quot;pref_key_auto_delete&amp;quot;
            android:summary=&amp;quot;@string/pref_summary_auto_delete&amp;quot;
            android:title=&amp;quot;@string/pref_title_auto_delete&amp;quot;
            android:defaultValue=&amp;quot;false&amp;quot;... /&amp;gt;
        &amp;lt;Preference 
            android:key=&amp;quot;pref_key_sms_delete_limit&amp;quot;
            android:dependency=&amp;quot;pref_key_auto_delete&amp;quot;
            android:summary=&amp;quot;@string/pref_summary_delete_limit&amp;quot;
            android:title=&amp;quot;@string/pref_title_sms_delete&amp;quot;... /&amp;gt;
        &amp;lt;Preference 
            android:key=&amp;quot;pref_key_mms_delete_limit&amp;quot;
            android:dependency=&amp;quot;pref_key_auto_delete&amp;quot;
            android:summary=&amp;quot;@string/pref_summary_delete_limit&amp;quot;
            android:title=&amp;quot;@string/pref_title_mms_delete&amp;quot; ... /&amp;gt;
    &amp;lt;/PreferenceCategory&amp;gt;
    ...
&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用子屏幕&quot;&gt;&lt;a href=&quot;#使用子屏幕&quot; class=&quot;headerlink&quot; title=&quot;使用子屏幕&quot;&gt;&lt;/a&gt;使用子屏幕&lt;/h2&gt;&lt;p&gt;如果想要将设定组防止在子屏幕中，可以将各组&lt;code&gt;Pref&lt;/code&gt;对象放置在&lt;code&gt;PreferenceScreen&lt;/code&gt;中。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;PreferenceScreen  xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;&amp;gt;
    &amp;lt;!-- opens a subscreen of settings --&amp;gt;
    &amp;lt;PreferenceScreen
        android:key=&amp;quot;button_voicemail_category_key&amp;quot;
        android:title=&amp;quot;@string/voicemail&amp;quot;
        android:persistent=&amp;quot;false&amp;quot;&amp;gt;
        &amp;lt;ListPreference
            android:key=&amp;quot;button_voicemail_provider_key&amp;quot;
            android:title=&amp;quot;@string/voicemail_provider&amp;quot; ... /&amp;gt;
        &amp;lt;!-- opens another nested subscreen --&amp;gt;
        &amp;lt;PreferenceScreen
            android:key=&amp;quot;button_voicemail_setting_key&amp;quot;
            android:title=&amp;quot;@string/voicemail_settings&amp;quot;
            android:persistent=&amp;quot;false&amp;quot;&amp;gt;
            ...
        &amp;lt;/PreferenceScreen&amp;gt;
        &amp;lt;RingtonePreference
            android:key=&amp;quot;button_voicemail_ringtone_key&amp;quot;
            android:title=&amp;quot;@string/voicemail_ringtone_title&amp;quot;
            android:ringtoneType=&amp;quot;notification&amp;quot; ... /&amp;gt;
        ...
    &amp;lt;/PreferenceScreen&amp;gt;
    ...
&amp;lt;/PreferenceScreen&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;使用intents&quot;&gt;&lt;a href=&quot;#使用intents&quot; class=&quot;headerlink&quot; title=&quot;使用intents&quot;&gt;&lt;/a&gt;使用intents&lt;/h2&gt;&lt;p&gt;一些情况下，可能需要使用pref子项打开一个不同的activity而非设置屏幕，比如使用浏览器来浏览网页。要在用户选中pref子项时调用&lt;code&gt;Intent&lt;/code&gt;，可以添加一个&lt;code&gt;&amp;lt;intent&amp;gt;&lt;/code&gt;元素作为相应&lt;code&gt;&amp;lt;Preference&amp;gt;&lt;/code&gt;元素的子项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Preference android:title=&amp;quot;@string/prefs_web_page&amp;quot; &amp;gt;
    &amp;lt;intent android:action=&amp;quot;android.intent.action.VIEW&amp;quot;
            android:data=&amp;quot;http://www.example.com&amp;quot; /&amp;gt;
&amp;lt;/Preference&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以通过下面的属性来创建显式或隐式的intent。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:action&lt;/code&gt;: The action to assign, as per the setAction() method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:data&lt;/code&gt;: The data to assign, as per the setData() method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:mimeType&lt;/code&gt;: The MIME type to assign, as per the setType() method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:targetClass&lt;/code&gt;: The class part of the component name, as per the setComponent() method.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;android:targetPackage&lt;/code&gt;: The package part of the component name, as per the setComponent() method. &lt;/p&gt;
&lt;h1 id=&quot;创建Pref-Activity&quot;&gt;&lt;a href=&quot;#创建Pref-Activity&quot; class=&quot;headerlink&quot; title=&quot;创建Pref Activity&quot;&gt;&lt;/a&gt;创建Pref Activity&lt;/h1&gt;&lt;p&gt;要在activity中展示设定，可以继承&lt;code&gt;PA&lt;/code&gt;类。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3.0以上版本应该使用&lt;code&gt;PreferenceFragment&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最重要的是记住，在&lt;code&gt;onCreate()&lt;/code&gt;回调中，并不载入布局视图。而是调用&lt;code&gt;addPreferencesFromResource()&lt;/code&gt;来添加XML中声明的pref。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SettingsActivity extends PreferenceActivity {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        addPreferencesFromResource(R.xml.preferences);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码已经足够供一些应用使用了。因为一旦用户修改某项pref，系统就将改变存储到默认的SP中，并供应用的其他组件读取。还有很多应用，需要额外的一些代码来侦听pref发生的变化。&lt;/p&gt;
&lt;h1 id=&quot;使用Pref-Fragments&quot;&gt;&lt;a href=&quot;#使用Pref-Fragments&quot; class=&quot;headerlink&quot; title=&quot;使用Pref Fragments&quot;&gt;&lt;/a&gt;使用Pref Fragments&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Fragments&lt;/code&gt;为应用提供了更加灵活的结构。所以，尽可能使用PF来展示设定而非PA。&lt;/p&gt;
&lt;p&gt;PF的实现非常简单，只需要定义&lt;code&gt;onCreate()&lt;/code&gt;方法来加载pref文件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static class SettingsFragment extends PreferenceFragment {
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Load the preferences from an XML resource
        addPreferencesFromResource(R.xml.preferences);
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以像添加其他&lt;code&gt;Fragment&lt;/code&gt;一样将PF添加到&lt;code&gt;Activity&lt;/code&gt;中。如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class SettingsActivity extends Activity {
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        // Display the fragment as the main content.
        getFragmentManager().beginTransaction()
                .replace(android.R.id.content, new SettingsFragment())
                .commit();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;注意：PF本身不具有&lt;code&gt;Context&lt;/code&gt;对象。如果需要&lt;code&gt;Context&lt;/code&gt;，可以调用&lt;code&gt;getActivity()&lt;/code&gt;。然而，调用该方法的时候需要注意，仅仅在fragment连接到activity上时调用。如果没有，或者被解除连接，将会返回null。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;设置默认值&quot;&gt;&lt;a href=&quot;#设置默认值&quot; class=&quot;headerlink&quot; title=&quot;设置默认值&quot;&gt;&lt;/a&gt;设置默认值&lt;/h1&gt;&lt;p&gt;创建的pref很可能决定着应用的一些重要行为，所以有必要在用户第一次打开应用时，创建每个pref都拥有默认值的关联SP文件。&lt;/p&gt;
&lt;p&gt;首先要做的是在XML中文件中为每个pref使用&lt;code&gt;android:defaultValue&lt;/code&gt;来指明默认值。这个值可以为适合相应&lt;code&gt;Preference&lt;/code&gt;对象的任意数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;!-- default value is a boolean --&amp;gt;
&amp;lt;CheckBoxPreference
    android:defaultValue=&amp;quot;true&amp;quot;
    ... /&amp;gt;

&amp;lt;!-- default value is a string --&amp;gt;
&amp;lt;ListPreference
    android:defaultValue=&amp;quot;@string/pref_syncConnectionTypes_default&amp;quot;
    ... /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后，在应用的主ACT的&lt;code&gt;onCreate()&lt;/code&gt;方法，以及任何可能的首次入口activity中调用&lt;code&gt;setDefaultValues()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PreferenceManager.setDefaultValues(this, R.xml.advanced_preferences, false);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在&lt;code&gt;onCreate()&lt;/code&gt;中调用保证了应用以默认设置初始化。这个方法有三个参数：应用的&lt;code&gt;Context&lt;/code&gt;，pref XML的资源ID，指示是否覆盖的布尔变量。&lt;/p&gt;
&lt;p&gt;只要将第三个参数设置为&lt;code&gt;false&lt;/code&gt;，便可以安全地在每次ACT启动时调用该方法，无需担心覆盖pref。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;应用一般都包含一些用户可以自定义的设置，比如是否推送通知，更新数据的频率等等。&lt;/p&gt;
&lt;p&gt;如果想要为应用提供设置，应该使用安卓的&lt;code&gt;Preference&lt;/code&gt;API来创建一致的用户体验。&lt;/p&gt;
&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1&gt;&lt;p&gt;与使用&lt;code&gt;View&lt;/code&gt;创造界面不同，设置是由xml文件中声明的各种&lt;code&gt;Preference&lt;/code&gt;的子类组成。&lt;/p&gt;
&lt;p&gt;一个&lt;code&gt;Preference&lt;/code&gt;对象构成一个设置。每个&lt;code&gt;Preference&lt;/code&gt;显示为列表中的一个子项，并提供合适的UI供用户交互。例如，&lt;code&gt;CheckBoxPreference&lt;/code&gt;创造一个勾选框子项，&lt;code&gt;ListPreference&lt;/code&gt;创造一个弹出选择列表对话框的子项。&lt;/p&gt;
&lt;p&gt;每个&lt;code&gt;Preference&lt;/code&gt;在系统使用的默认的&lt;code&gt;SharedPreferences&lt;/code&gt;文件中存在一个对应的键值对。用户更改设置后，系统在SP文件中更新相应的值。只有当需要从SP中读取值以决定应用行为时，才需要直接与SP相交互。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>A Bug of TabLayout</title>
    <link href="http://yoursite.com/2016/01/04/Bug-of-TabLayout/"/>
    <id>http://yoursite.com/2016/01/04/Bug-of-TabLayout/</id>
    <published>2016-01-03T16:26:01.000Z</published>
    <updated>2016-01-03T16:31:16.972Z</updated>
    
    <content type="html">&lt;p&gt;In Google’s design support library, there is a bug for version 22.2.1 that the &lt;code&gt;TabLayout&lt;/code&gt; in &lt;code&gt;Toolbar&lt;/code&gt; may not display. I spent neary an hour debugging for this problem. There is a work-around for this bug:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;tabLayout.post(new Runnable() {
    @Override
    public void run() {
        tabLayout.setupWithViewPager(viewPager);
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;But the easiest way is to upgrade the design library to version 23.&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;In Google’s design support library, there is a bug for version 22.2.1 that the &lt;code&gt;TabLayout&lt;/code&gt; in &lt;code&gt;Toolbar&lt;/code&gt; may not dis
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yoursite.com/tags/Material-Design/"/>
    
  </entry>
  
  <entry>
    <title>安卓导航 - 提供合适的后退导航</title>
    <link href="http://yoursite.com/2016/01/03/Providing-Proper-Back-Navigation/"/>
    <id>http://yoursite.com/2016/01/03/Providing-Proper-Back-Navigation/</id>
    <published>2016-01-03T10:50:14.000Z</published>
    <updated>2016-01-03T11:37:13.407Z</updated>
    
    <content type="html">&lt;p&gt;后退导航是指用户如何从访问过的屏幕中向后移动。所有的安卓设备都提供有一个后退键，所以&lt;strong&gt;你的应用不应该再增加一个后退按钮。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在大多数的情况中，系统在用户导航时维持着一个后退栈。这使得系统能够再用户按下后退键之后合适地向后导航。然而，有一些情况下，你需要手动指明后退行为，以提供更好的用户体验。&lt;/p&gt;
&lt;p&gt;需要手动指明后退行为的导航模式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户通过一条通知、一个桌面挂件或导航抽屉直接进入到一个深层次的activity时。&lt;/li&gt;
&lt;li&gt;用户在fragment见导航的某些情况。&lt;/li&gt;
&lt;li&gt;用户在&lt;code&gt;WebView&lt;/code&gt;的网页中导航时。&lt;/li&gt;
&lt;/ul&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;为深链接合成新的后退栈&quot;&gt;&lt;a href=&quot;#为深链接合成新的后退栈&quot; class=&quot;headerlink&quot; title=&quot;为深链接合成新的后退栈&quot;&gt;&lt;/a&gt;为深链接合成新的后退栈&lt;/h1&gt;&lt;p&gt;一般，系统在用户不断导航的过程中逐步地构建起后退栈。然而，当用户通过一个深层链接直接进入应用时，有必要去合成一个新的后退栈，因为activity处在一个新的任务中，根本没有任何后退栈。&lt;/p&gt;
&lt;h2 id=&quot;在manifest中明确父activity&quot;&gt;&lt;a href=&quot;#在manifest中明确父activity&quot; class=&quot;headerlink&quot; title=&quot;在manifest中明确父activity&quot;&gt;&lt;/a&gt;在manifest中明确父activity&lt;/h2&gt;&lt;p&gt;// 见上一篇文章&lt;/p&gt;
&lt;h2 id=&quot;启动activity时创造后退栈&quot;&gt;&lt;a href=&quot;#启动activity时创造后退栈&quot; class=&quot;headerlink&quot; title=&quot;启动activity时创造后退栈&quot;&gt;&lt;/a&gt;启动activity时创造后退栈&lt;/h2&gt;&lt;p&gt;向后退栈中添加activity发生在将用户带入应用的事件的一开始。也就是说，使用&lt;code&gt;TaskStackBuilder&lt;/code&gt;API而非&lt;code&gt;startActivity()&lt;/code&gt;来定义应该放入新后退栈的每个activity。然后，通过调用&lt;code&gt;startActivities()&lt;/code&gt;来启动目标activity，或者创建调用&lt;code&gt;getPendingIntent()&lt;/code&gt;合适的&lt;code&gt;PendingIntent&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如，当某个通知将用户带入至应用阶层中的一个深层activity时，可以使用下面的代码来创建一个&lt;code&gt;PendingIntent&lt;/code&gt;来启动activity，并为目标任务插入一个新的后退栈。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Intent for the activity to open when user selects the notification
Intent detailsIntent = new Intent(this, DetailsActivity.class);

// Use TaskStackBuilder to build the back stack and get the PendingIntent
PendingIntent pendingIntent =
        TaskStackBuilder.create(this)
                        // add all of DetailsActivity&amp;apos;s parents to the stack,
                        // followed by DetailsActivity itself
                        .addNextIntentWithParentStack(upIntent)
                        .getPendingIntent(0, PendingIntent.FLAG_UPDATE_CURRENT);

NotificationCompat.Builder builder = new NotificationCompat.Builder(this);
builder.setContentIntent(pendingIntent);
...
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;获得的&lt;code&gt;PendingIntent&lt;/code&gt;不仅指明了将要启动的activity（在&lt;code&gt;detailsIntent&lt;/code&gt;中定义），而且指明了应该插入至任务重的后退栈（&lt;code&gt;DetailsActivity&lt;/code&gt;的所有父亲）。所以当该activity启动后，按下后退键会在其父activity中向后导航。&lt;/p&gt;
&lt;h1 id=&quot;为Fragment实现向后导航&quot;&gt;&lt;a href=&quot;#为Fragment实现向后导航&quot; class=&quot;headerlink&quot; title=&quot;为Fragment实现向后导航&quot;&gt;&lt;/a&gt;为Fragment实现向后导航&lt;/h1&gt;&lt;p&gt;在应用中使用fragment时，独立的&lt;code&gt;FragmentTransaction&lt;/code&gt;对象可能代表了应该添加至后退栈的上下文变化。例如，通过交换fragment实现master/detail flow时，应该确保在detail屏幕按下后退键时能够回到master屏幕。要实现的话，在commit之前调用&lt;code&gt;addToBackStack()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Works with either the framework FragmentManager or the
// support package FragmentManager (getSupportFragmentManager).
getSupportFragmentManager().beginTransaction()
                           .add(detailFragment, &amp;quot;detail&amp;quot;)
                           // Add this transaction to the back stack
                           .addToBackStack()
                           .commit();
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当后退栈中存在&lt;code&gt;FragmentTransaction&lt;/code&gt;对象时，用户按下后退键后，&lt;code&gt;FragmentManager&lt;/code&gt;将会弹出后退栈中最近的一次transaction，并执行相反的操作（比如移除某个fragment，如果该transaction增添了它）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：当transaction是水平导航（如切换tab）时，或者修改内容表现（如调整过滤器）时，不应该将其添加至后退栈。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果应用更新更新了其他用户界面元素，以反应fragment的当前状态，比如action bar，记得在commit的时候更新UI。当通过后退栈返回的时候，同样应该更新UI。可以通过设置&lt;code&gt;FragmentManager.OnBackStackChangedListener&lt;/code&gt;来侦听&lt;code&gt;FragmentTransaction&lt;/code&gt;被反转的事件。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;getSupportFragmentManager().addOnBackStackChangedListener(
        new FragmentManager.OnBackStackChangedListener() {
            public void onBackStackChanged() {
                // Update your UI here.
            }
        });
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;为WebView实现后退栈&quot;&gt;&lt;a href=&quot;#为WebView实现后退栈&quot; class=&quot;headerlink&quot; title=&quot;为WebView实现后退栈&quot;&gt;&lt;/a&gt;为WebView实现后退栈&lt;/h1&gt;&lt;p&gt;如果应用的一部分包含在&lt;code&gt;WebView&lt;/code&gt;之中，可能适合使用后退键来遍历浏览历史。可以覆盖&lt;code&gt;onBackPressed()&lt;/code&gt;方法，来代理&lt;code&gt;WebView&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;@Override
public void onBackPressed() {
    if (mWebView.canGoBack()) {
        mWebView.goBack();
        return;
    }

    // Otherwise defer to system default behavior.
    super.onBackPressed();
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意，当网页高度动态的时候可能产生大量的历史记录。&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;后退导航是指用户如何从访问过的屏幕中向后移动。所有的安卓设备都提供有一个后退键，所以&lt;strong&gt;你的应用不应该再增加一个后退按钮。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在大多数的情况中，系统在用户导航时维持着一个后退栈。这使得系统能够再用户按下后退键之后合适地向后导航。然而，有一些情况下，你需要手动指明后退行为，以提供更好的用户体验。&lt;/p&gt;
&lt;p&gt;需要手动指明后退行为的导航模式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户通过一条通知、一个桌面挂件或导航抽屉直接进入到一个深层次的activity时。&lt;/li&gt;
&lt;li&gt;用户在fragment见导航的某些情况。&lt;/li&gt;
&lt;li&gt;用户在&lt;code&gt;WebView&lt;/code&gt;的网页中导航时。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Navigation" scheme="http://yoursite.com/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>安卓导航 - 提供Up导航</title>
    <link href="http://yoursite.com/2016/01/03/Providing-Up-Navigation/"/>
    <id>http://yoursite.com/2016/01/03/Providing-Up-Navigation/</id>
    <published>2016-01-03T10:21:31.000Z</published>
    <updated>2016-02-26T13:00:24.495Z</updated>
    
    <content type="html">&lt;p&gt;所有不是主入口的屏幕都应该为用户提供一个通过action bar的Up按钮导航至逻辑父屏幕的方式。&lt;/p&gt;
&lt;h1 id=&quot;明确父Activity&quot;&gt;&lt;a href=&quot;#明确父Activity&quot; class=&quot;headerlink&quot; title=&quot;明确父Activity&quot;&gt;&lt;/a&gt;明确父Activity&lt;/h1&gt;&lt;p&gt;要实现Up导航，第一步是为每个activity声明合适的父activity。这样系统就可以在manifest中获得activity的逻辑父页面，方便实现导航模式。&lt;/p&gt;
&lt;p&gt;从安卓4.1开始，可以通过在&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;中指明&lt;code&gt;android:parentActivityName&lt;/code&gt;属性来声明逻辑父activity。 4.0以下的版本这里略去。&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;application ... &amp;gt;
    ...
    &amp;lt;!-- The main/home activity (it has no parent activity) --&amp;gt;
    &amp;lt;activity
        android:name=&amp;quot;com.example.myfirstapp.MainActivity&amp;quot; ...&amp;gt;
        ...
    &amp;lt;/activity&amp;gt;
    &amp;lt;!-- A child of the main activity --&amp;gt;
    &amp;lt;activity
        android:name=&amp;quot;com.example.myfirstapp.DisplayMessageActivity&amp;quot;
        android:label=&amp;quot;@string/title_activity_display_message&amp;quot;
        android:parentActivityName=&amp;quot;com.example.myfirstapp.MainActivity&amp;quot; &amp;gt;
        &amp;lt;!-- Parent activity meta-data to support 4.0 and lower --&amp;gt;
        &amp;lt;meta-data
            android:name=&amp;quot;android.support.PARENT_ACTIVITY&amp;quot;
            android:value=&amp;quot;com.example.myfirstapp.MainActivity&amp;quot; /&amp;gt;
    &amp;lt;/activity&amp;gt;
&amp;lt;/application&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样声明之后，就可以使用&lt;code&gt;NavUtils&lt;/code&gt;API来进行合适的Up导航。&lt;/p&gt;
&lt;h1 id=&quot;添加Up动作&quot;&gt;&lt;a href=&quot;#添加Up动作&quot; class=&quot;headerlink&quot; title=&quot;添加Up动作&quot;&gt;&lt;/a&gt;添加Up动作&lt;/h1&gt;&lt;p&gt;调用&lt;code&gt;setDisplayHomeAsUpEnabled()&lt;/code&gt;方法可以启用action bar的Up导航：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onCreate&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Bundle savedInstanceState)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    getActionBar().setDisplayHomeAsUpEnabled(&lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这样可以在应用图标旁边添加一个向左的箭头，当用户点击之后，activity就会收到一个&lt;code&gt;onOptionsItemSelected()&lt;/code&gt;调用。动作的ID为&lt;code&gt;android.R.id.home&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;Up导航至父Activity&quot;&gt;&lt;a href=&quot;#Up导航至父Activity&quot; class=&quot;headerlink&quot; title=&quot;Up导航至父Activity&quot;&gt;&lt;/a&gt;Up导航至父Activity&lt;/h1&gt;&lt;p&gt;要想在用户点击应用图标后向上导航，可以使用&lt;code&gt;NavUtils&lt;/code&gt;类的静态方法，&lt;code&gt;navigateUpFromSameTask()&lt;/code&gt;。调用这个方法时，它终结当前的activity并启动或继续一个合适的父activity。如果目标父activity在任务的后退栈中，它将被取出到最前。取出的方法取决于父activity是否能够处理&lt;code&gt;onNewIntent()&lt;/code&gt;调用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果父activity启用了&lt;code&gt;&amp;lt;singleTop&amp;gt;&lt;/code&gt;模式，或者&lt;code&gt;up&lt;/code&gt;intent包含了&lt;code&gt;FLAG_ACTIVITY_CLEAR_TOP&lt;/code&gt;,父activity将被带到栈顶，并且通过&lt;code&gt;onNewIntent()&lt;/code&gt;方法接收intent。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果父activity启动了&lt;code&gt;&amp;lt;standard&amp;gt;&lt;/code&gt;模式，并且&lt;code&gt;up&lt;/code&gt;intent不包含&lt;code&gt;FLAG_ACTIVITY_CLEAR_TOP&lt;/code&gt;,父activity将从栈中移除，并在栈顶创建一个该activity的新实例来接收intent。&lt;/p&gt;
  &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onOptionsItemSelected&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MenuItem item)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (item.getItemId()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;comment&quot;&gt;// Respond to the action bar&#39;s Up/Home button&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; android.R.id.home:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        NavUtils.navigateUpFromSameTask(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onOptionsItemSelected(item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然而，&lt;strong&gt;仅仅当应用是当前任务的所有者&lt;/strong&gt;时使用&lt;code&gt;navigateUpFromSameTask()&lt;/code&gt;才合适（就是说，用户从该应用开始任务）。否则，如果activity由其他应用的任务启动，Up导航应该创建一个属于自己应用的新的任务，着需要创建一个新的后退栈。&lt;/p&gt;
&lt;h2 id=&quot;以新的后退栈向上导航&quot;&gt;&lt;a href=&quot;#以新的后退栈向上导航&quot; class=&quot;headerlink&quot; title=&quot;以新的后退栈向上导航&quot;&gt;&lt;/a&gt;以新的后退栈向上导航&lt;/h2&gt;&lt;p&gt;如果activity提供了intent filter来允许其他应用启动activity，那么实现&lt;code&gt;onOptionsItemSelected()&lt;/code&gt;回调时，当用户由其他应用进入activity并点击Up按钮后，应用应该在向上导航之前，启动一个有合适的后退栈的新的任务。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;annotation&quot;&gt;@Override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onOptionsItemSelected&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(MenuItem item)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;switch&lt;/span&gt; (item.getItemId()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// Respond to the action bar&#39;s Up/Home button&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; android.R.id.home:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Intent upIntent = NavUtils.getParentActivityIntent(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (NavUtils.shouldUpRecreateTask(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, upIntent)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// This activity is NOT part of this app&#39;s task, so create a new task&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// when navigating up, with a synthesized back stack.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            TaskStackBuilder.create(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// Add all of this activity&#39;s parents to the back stack&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .addNextIntentWithParentStack(upIntent)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    &lt;span class=&quot;comment&quot;&gt;// Navigate up to the closest parent&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;                    .startActivities();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// This activity is part of this app&#39;s task, so simply&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;// navigate up to the logical parent activity.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            NavUtils.navigateUpTo(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, upIntent);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;true&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;.onOptionsItemSelected(item);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;所有不是主入口的屏幕都应该为用户提供一个通过action bar的Up按钮导航至逻辑父屏幕的方式。&lt;/p&gt;
&lt;h1 id=&quot;明确父Activity&quot;&gt;&lt;a href=&quot;#明确父Activity&quot; class=&quot;headerlink&quot; title=&quot;明确父Activity&quot;&gt;&lt;/a&gt;明确父Activity&lt;/h1&gt;&lt;p&gt;要实现Up导航，第一步是为每个activity声明合适的父activity。这样系统就可以在manifest中获得activity的逻辑父页面，方便实现导航模式。&lt;/p&gt;
&lt;p&gt;从安卓4.1开始，可以通过在&lt;code&gt;&amp;lt;activity&amp;gt;&lt;/code&gt;中指明&lt;code&gt;android:parentActivityName&lt;/code&gt;属性来声明逻辑父activity。 4.0以下的版本这里略去。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Navigation" scheme="http://yoursite.com/tags/Navigation/"/>
    
  </entry>
  
  <entry>
    <title>安卓导航 - 创建导航抽屉</title>
    <link href="http://yoursite.com/2016/01/03/Creating-a-Navigation-Drawer/"/>
    <id>http://yoursite.com/2016/01/03/Creating-a-Navigation-Drawer/</id>
    <published>2016-01-03T06:46:01.000Z</published>
    <updated>2016-01-03T11:37:14.891Z</updated>
    
    <content type="html">&lt;p&gt;导航抽屉式一个屏幕左侧展示应用主要导航选项的面板。它一般隐藏起来，当用户从左侧滑动屏幕或在应用最顶级层面上点击应用图标时会出现。&lt;/p&gt;
&lt;h1 id=&quot;创建DrawerLayout&quot;&gt;&lt;a href=&quot;#创建DrawerLayout&quot; class=&quot;headerlink&quot; title=&quot;创建DrawerLayout&quot;&gt;&lt;/a&gt;创建DrawerLayout&lt;/h1&gt;&lt;p&gt;要添加导航抽屉，首先在布局的根视图上添加一个&lt;code&gt;DrawerLayout&lt;/code&gt;。在&lt;code&gt;DrawerLayout&lt;/code&gt;中添加显示一个屏幕主要内容的view，和一个显示抽屉内容的view。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;例如，下面的布局使用了一个有两个子view的&lt;code&gt;DrawerLayout&lt;/code&gt;：一个包含主要内容（由&lt;code&gt;Fragment&lt;/code&gt;填充）的&lt;code&gt;FrameLayout&lt;/code&gt;和一个作为导航抽屉的&lt;code&gt;ListView&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;android.support.v4.widget.DrawerLayout
    xmlns:android=&amp;quot;http://schemas.android.com/apk/res/android&amp;quot;
    android:id=&amp;quot;@+id/drawer_layout&amp;quot;
    android:layout_width=&amp;quot;match_parent&amp;quot;
    android:layout_height=&amp;quot;match_parent&amp;quot;&amp;gt;
    &amp;lt;!-- The main content view --&amp;gt;
    &amp;lt;FrameLayout
        android:id=&amp;quot;@+id/content_frame&amp;quot;
        android:layout_width=&amp;quot;match_parent&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot; /&amp;gt;
    &amp;lt;!-- The navigation drawer --&amp;gt;
    &amp;lt;ListView android:id=&amp;quot;@+id/left_drawer&amp;quot;
        android:layout_width=&amp;quot;240dp&amp;quot;
        android:layout_height=&amp;quot;match_parent&amp;quot;
        android:layout_gravity=&amp;quot;start&amp;quot;
        android:choiceMode=&amp;quot;singleChoice&amp;quot;
        android:divider=&amp;quot;@android:color/transparent&amp;quot;
        android:dividerHeight=&amp;quot;0dp&amp;quot;
        android:background=&amp;quot;#111&amp;quot;/&amp;gt;
&amp;lt;/android.support.v4.widget.DrawerLayout&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这个布局展示了一些重要的布局特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主内容view必须是&lt;code&gt;DrawerLayout&lt;/code&gt;的&lt;strong&gt;第一个子view&lt;/strong&gt;，因为XML的顺序暗含着Z-ordering，抽屉必须在内容的顶上。&lt;/li&gt;
&lt;li&gt;主内容view应该匹配父视图的宽和高，因为当抽屉隐藏时，它代表了整个UI。&lt;/li&gt;
&lt;li&gt;抽屉view必须用&lt;code&gt;android:layout_gravity&lt;/code&gt;指明水平的重力方向。为了支持一些从右到左的语言，可以使用”start”代替”left”。&lt;/li&gt;
&lt;li&gt;抽屉view的宽度用&lt;code&gt;dp&lt;/code&gt;单位指明，高度匹配父视图。抽屉的宽度应该不超过320dp，这样用户可以总能看到主内容的一部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;初始化抽屉列表&quot;&gt;&lt;a href=&quot;#初始化抽屉列表&quot; class=&quot;headerlink&quot; title=&quot;初始化抽屉列表&quot;&gt;&lt;/a&gt;初始化抽屉列表&lt;/h1&gt;&lt;p&gt;在activity中，初始化导航抽屉的列表是最开始要做的事情之一。具体如何实现取决于应用的内容，但导航抽屉一般都包含一个&lt;code&gt;ListView&lt;/code&gt;，所以列表应该由一个&lt;code&gt;Adapter&lt;/code&gt;来填充。&lt;/p&gt;
&lt;p&gt;下面是使用字符串数组来初始化导航列表的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {
    private String[] mPlanetTitles;
    private DrawerLayout mDrawerLayout;
    private ListView mDrawerList;
    ...

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mPlanetTitles = getResources().getStringArray(R.array.planets_array);
        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
        mDrawerList = (ListView) findViewById(R.id.left_drawer);

        // Set the adapter for the list view
        mDrawerList.setAdapter(new ArrayAdapter&amp;lt;String&amp;gt;(this,
                R.layout.drawer_list_item, mPlanetTitles));
        // Set the list&amp;apos;s click listener
        mDrawerList.setOnItemClickListener(new DrawerItemClickListener());

        ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面的代码调用了&lt;code&gt;setOnItemClickListener()&lt;/code&gt;来接收列表中的点击事件。下面的部分将展示如何实现这个接口，并在用户选择时改变内容视图。&lt;/p&gt;
&lt;h1 id=&quot;处理导航点击事件&quot;&gt;&lt;a href=&quot;#处理导航点击事件&quot; class=&quot;headerlink&quot; title=&quot;处理导航点击事件&quot;&gt;&lt;/a&gt;处理导航点击事件&lt;/h1&gt;&lt;p&gt;当用户选择了抽屉列表中的一个项目时，系统调用&lt;code&gt;onItemClick()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;在这个方法中所做的事情取决于如何实现应用的结构。下面的例子中，选择列表中的每个项目会往主内容视图中插入一个不同的&lt;code&gt;Fragment&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;private class DrawerItemClickListener implements ListView.OnItemClickListener {
    @Override
    public void onItemClick(AdapterView parent, View view, int position, long id) {
        selectItem(position);
    }
}

/** Swaps fragments in the main content view */
private void selectItem(int position) {
    // Create a new fragment and specify the planet to show based on position
    Fragment fragment = new PlanetFragment();
    Bundle args = new Bundle();
    args.putInt(PlanetFragment.ARG_PLANET_NUMBER, position);
    fragment.setArguments(args);

    // Insert the fragment by replacing any existing fragment
    FragmentManager fragmentManager = getFragmentManager();
    fragmentManager.beginTransaction()
                   .replace(R.id.content_frame, fragment)
                   .commit();

    // Highlight the selected item, update the title, and close the drawer
    mDrawerList.setItemChecked(position, true);
    setTitle(mPlanetTitles[position]);
    mDrawerLayout.closeDrawer(mDrawerList);
}

@Override
public void setTitle(CharSequence title) {
    mTitle = title;
    getActionBar().setTitle(mTitle);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;侦听打开和关闭事件&quot;&gt;&lt;a href=&quot;#侦听打开和关闭事件&quot; class=&quot;headerlink&quot; title=&quot;侦听打开和关闭事件&quot;&gt;&lt;/a&gt;侦听打开和关闭事件&lt;/h1&gt;&lt;p&gt;要侦听抽屉的打开和关闭的事件，调用&lt;code&gt;DrawerLayout&lt;/code&gt;的&lt;code&gt;setDrawerListener()&lt;/code&gt;方法，并传入自己的实现。这个接口提供了抽屉打开和关闭的事件回调。&lt;/p&gt;
&lt;p&gt;然而，如果activity包含了action bar,那么可以选择继承&lt;code&gt;ActionBarDrawerToggle&lt;/code&gt;类来替代。后者也实现了相同的接口，所以仍然可以重写这些回调。而且它使action bar图标与导航抽屉的互动更加便利。&lt;/p&gt;
&lt;p&gt;当抽屉变得可见时，首先应该修改action bar的内容，比如改变标题，移除主内容相关的一些项目。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {
    private DrawerLayout mDrawerLayout;
    private ActionBarDrawerToggle mDrawerToggle;
    private CharSequence mDrawerTitle;
    private CharSequence mTitle;
    ...

    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        ...

        mTitle = mDrawerTitle = getTitle();
        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
        mDrawerToggle = new ActionBarDrawerToggle(this, mDrawerLayout,
                R.drawable.ic_drawer, R.string.drawer_open, R.string.drawer_close) {

            /** Called when a drawer has settled in a completely closed state. */
            public void onDrawerClosed(View view) {
                super.onDrawerClosed(view);
                getActionBar().setTitle(mTitle);
                invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
            }

            /** Called when a drawer has settled in a completely open state. */
            public void onDrawerOpened(View drawerView) {
                super.onDrawerOpened(drawerView);
                getActionBar().setTitle(mDrawerTitle);
                invalidateOptionsMenu(); // creates call to onPrepareOptionsMenu()
            }
        };

        // Set the drawer toggle as the DrawerListener
        mDrawerLayout.setDrawerListener(mDrawerToggle);
    }

    /* Called whenever we call invalidateOptionsMenu() */
    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // If the nav drawer is open, hide action items related to the content view
        boolean drawerOpen = mDrawerLayout.isDrawerOpen(mDrawerList);
        menu.findItem(R.id.action_websearch).setVisible(!drawerOpen);
        return super.onPrepareOptionsMenu(menu);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&quot;打开和关闭时的App图标&quot;&gt;&lt;a href=&quot;#打开和关闭时的App图标&quot; class=&quot;headerlink&quot; title=&quot;打开和关闭时的App图标&quot;&gt;&lt;/a&gt;打开和关闭时的App图标&lt;/h1&gt;&lt;p&gt;如果使用了action bar，那么应该允许用户通过点击应用图标来打开或关闭抽屉。而且应用应该通过一个特殊的图标来展示导航抽屉的存在。这可以通过&lt;code&gt;ActionBarDrawerToggle&lt;/code&gt;来实现。&lt;/p&gt;
&lt;p&gt;为了使其工作，使用其构造方法创建一个实例，要求下面的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;drawer所在的&lt;code&gt;Activity&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DrawerLayout&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;作为抽屉标识的drawable资源。&lt;/li&gt;
&lt;li&gt;一个描述打开抽屉动作的字符串资源（为了无障碍使用）&lt;/li&gt;
&lt;li&gt;一个描述关闭抽屉动作的字符串资源（为了无障碍使用）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，无论是否创建一个&lt;code&gt;ActionBarDrawerToggle&lt;/code&gt;子类作为抽屉的侦听器，都需要在贯穿activity的生命周期中的一些地方调用它。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public class MainActivity extends Activity {
    private DrawerLayout mDrawerLayout;
    private ActionBarDrawerToggle mDrawerToggle;
    ...

    public void onCreate(Bundle savedInstanceState) {
        ...

        mDrawerLayout = (DrawerLayout) findViewById(R.id.drawer_layout);
        mDrawerToggle = new ActionBarDrawerToggle(
                this,                  /* host Activity */
                mDrawerLayout,         /* DrawerLayout object */
                R.drawable.ic_drawer,  /* nav drawer icon to replace &amp;apos;Up&amp;apos; caret */
                R.string.drawer_open,  /* &amp;quot;open drawer&amp;quot; description */
                R.string.drawer_close  /* &amp;quot;close drawer&amp;quot; description */
                ) {

            /** Called when a drawer has settled in a completely closed state. */
            public void onDrawerClosed(View view) {
                super.onDrawerClosed(view);
                getActionBar().setTitle(mTitle);
            }

            /** Called when a drawer has settled in a completely open state. */
            public void onDrawerOpened(View drawerView) {
                super.onDrawerOpened(drawerView);
                getActionBar().setTitle(mDrawerTitle);
            }
        };

        // Set the drawer toggle as the DrawerListener
        mDrawerLayout.setDrawerListener(mDrawerToggle);

        getActionBar().setDisplayHomeAsUpEnabled(true);
        getActionBar().setHomeButtonEnabled(true);
    }

    @Override
    protected void onPostCreate(Bundle savedInstanceState) {
        super.onPostCreate(savedInstanceState);
        // Sync the toggle state after onRestoreInstanceState has occurred.
        mDrawerToggle.syncState();
    }

    @Override
    public void onConfigurationChanged(Configuration newConfig) {
        super.onConfigurationChanged(newConfig);
        mDrawerToggle.onConfigurationChanged(newConfig);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        // Pass the event to ActionBarDrawerToggle, if it returns
        // true, then it has handled the app icon touch event
        if (mDrawerToggle.onOptionsItemSelected(item)) {
          return true;
        }
        // Handle your other action bar items...

        return super.onOptionsItemSelected(item);
    }

    ...
}
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;导航抽屉式一个屏幕左侧展示应用主要导航选项的面板。它一般隐藏起来，当用户从左侧滑动屏幕或在应用最顶级层面上点击应用图标时会出现。&lt;/p&gt;
&lt;h1 id=&quot;创建DrawerLayout&quot;&gt;&lt;a href=&quot;#创建DrawerLayout&quot; class=&quot;headerlink&quot; title=&quot;创建DrawerLayout&quot;&gt;&lt;/a&gt;创建DrawerLayout&lt;/h1&gt;&lt;p&gt;要添加导航抽屉，首先在布局的根视图上添加一个&lt;code&gt;DrawerLayout&lt;/code&gt;。在&lt;code&gt;DrawerLayout&lt;/code&gt;中添加显示一个屏幕主要内容的view，和一个显示抽屉内容的view。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="Navigation" scheme="http://yoursite.com/tags/Navigation/"/>
    
  </entry>
  
</feed>
