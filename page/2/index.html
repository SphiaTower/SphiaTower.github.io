<!doctype html>



  


<html class="theme-next muse use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.googleapis.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="Welcome to SPHIA" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Welcome to SPHIA">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Welcome to SPHIA">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Welcome to SPHIA">
<meta name="twitter:description">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>

  <title> Welcome to SPHIA </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Welcome to SPHIA</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            Tags
          </a>
        </li>
      

      
      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">

    

    
    

    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/05/12/elasticsearch-sniffer/" itemprop="url">
                  ES中隐藏的关键调优 - Sniffer
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-05-12T19:28:07+08:00" content="2019-05-12">
              2019-05-12
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="默认情况下，流量全部打到VIP的Master节点"><a href="#默认情况下，流量全部打到VIP的Master节点" class="headerlink" title="默认情况下，流量全部打到VIP的Master节点"></a>默认情况下，流量全部打到VIP的Master节点</h2><p>ES集群中，节点可以粗略地分成Master节点、Data节点、Client节点三种。在笔者使用的一个ES服务中，集群没有Client节点，只有另两种节点。在其中，Data节点的机器性能非常高，而Master节点则是低配置的普通机器。</p>
<p>在使用ES的官方rest high level client时，我们只需要提供一个endpoint URL，就可以访问远程ES集群。那么问题来了，客户端拿到这个URL之后，访问的究竟是哪台机器呢？是某个主节点？全部主节点？还是全部节点？一般情况下，这个问题似乎没有那么重要。但是当Master节点和Data节点性能差异非常明显的情况下，ES客户端的访问逻辑就变得非常重要。比如，如果所有请求都被打到性能较差的Master节点中，甚至只打到Master节点中的某一个具体节点中，那么ES集群就难以发挥出真正的性能了。</p>
<p>首先我们要分析的是，服务商提供给我们的endpoint究竟是什么。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">http:</span><span class="comment">//sample.es.cluster.com:9200</span></span><br></pre></td></tr></table></figure></p>
<p>如上面的一个简单的endpoint，根据DNS的原理可知，这个域名的背后不一定只有一个IP。使用网络工具，我们很容易就可以查到这个域名URL背后的几个IP。那么这几个IP是全部节点的IP？还是其中一部分呢？</p>
<p>很多情况下，服务商都会使用所有Master节点的IP。特别是当我们需要对集群进行配置操作时，请求都需要Master节点进行处理。到此，答案就已经揭晓，我们使用官方client指定endpoint后，客户端的所有请求就会简单地打到这个endpoint的域名上，再使用DNS自身的负载均衡功能，打到不同的Master节点上。</p>
<h2 id="如果Master节点性能较差，集群负载飙升"><a href="#如果Master节点性能较差，集群负载飙升" class="headerlink" title="如果Master节点性能较差，集群负载飙升"></a>如果Master节点性能较差，集群负载飙升</h2><h2 id="使用默认的Sniffer配置，流量达到全部节点"><a href="#使用默认的Sniffer配置，流量达到全部节点" class="headerlink" title="使用默认的Sniffer配置，流量达到全部节点"></a>使用默认的Sniffer配置，流量达到全部节点</h2><p>ES提供了一个简单的sniffer库。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="title">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">artifactId</span>&gt;</span>elasticsearch-rest-client-sniffer<span class="tag">&lt;/<span class="title">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">version</span>&gt;</span>8.0.0<span class="tag">&lt;/<span class="title">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个Sniffer虽然代码写得有些复杂，但是功能其实很简单。就是调用ES的Rest API，如<code>/_nodes/http</code>，获取ES集群的节点信息，解析后，为<code>RestClient</code>设置可用的所有<code>HttpHost</code>。其他无非是增加了定时更新和失败重试功能而已。</p>
<p>默认情况下，获取全部节点。</p>
<h2 id="定制HostsSniffer，流量只达到Data节点"><a href="#定制HostsSniffer，流量只达到Data节点" class="headerlink" title="定制HostsSniffer，流量只达到Data节点"></a>定制HostsSniffer，流量只达到Data节点</h2><p>增加参数即可，只指定Data节点</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/27/elasticsearch-nodes/" itemprop="url">
                  Elasticsearch中节点类型的梳理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-04-27T22:31:45+08:00" content="2019-04-27">
              2019-04-27
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用ES时，很多时候我们都会使用服务商提供的开箱即用的ES版本，只需要拿到endpoint地址，用户名，密码，就可以创建客户端实例，如<code>RestHighLevelClient</code>，对ES进行访问了。然而，随着集群索引的文档数目或QPS不断增多，简单地使用默认配置或者“祖传配置”，就难以应对了。这种时候，最简单的办法就是增加ES集群的节点数。可实际上，如果不了解ES集群的构成方式，即使大量增加节点数，很多时候集群性能也不会有大幅提升，反而空耗了大量的资源。</p>
<p>ES中节点的分类说简单也简单，说复杂也复杂。简单在，ES中本身各种节点的定义非常直接明显；而复杂在，不同层次的节点类型往往被混合在一起。下面我们来分各种层次看一看节点的不同类型。</p>
<h2 id="Master节点和Data节点"><a href="#Master节点和Data节点" class="headerlink" title="Master节点和Data节点"></a>Master节点和Data节点</h2><p>ES中最经常提到的节点类型就是Master节点和Data节点了。然而实际上，与其称其为节点，不如说Master和Data是一个节点的两个正交的属性。一个节点可以同时是Master节点和Data节点，可以是其中一种，也可以都不是（Client节点）。</p>
<p>Master属性：如果一个节点具有Master属性，那么该节点可以用来处理一些集群范围的工作，如索引的创建和删除，以及shard的分配等。<br>Data属性：如果一个节点具有Data属性，那么该节点就可以存放索引数据，进行索引的增删改查等操作。</p>
<p>ES官方建议不要将Master节点和Data节点混用，使用单独的两种节点会带来更好的性能和稳定性。</p>
<h2 id="协调节点"><a href="#协调节点" class="headerlink" title="协调节点"></a>协调节点</h2><p>协调节点与上面提到的两种节点并非同一个维度上的概念。在ES中，任何一个节点都可以随时作为协调节点，其作用是集群内请求的路由和多个replica的负载均衡。其实这个概念非常简单，ES客户端可以将ES操作请求发给ES集群中的任何一个节点，这时收到请求的节点就成为了一个协调节点，协调节点会判断该请求所需要涉及的实际Data节点，然后将请求转发给其中一个真正处理的Data节点（也可以是自己，也可以涉及多个节点，如搜索和批量操作）。</p>
<p>协调节点本质上起到服务端的路由和负载均衡作用，与很多缓存工具的实现不同，ES的路由完全是交给服务端处理的。即使在客户端调用时指定了routing参数，也需要提交给任一协调节点之后，再有协调节点进行路由。</p>
<h2 id="Client节点（只协调节点）"><a href="#Client节点（只协调节点）" class="headerlink" title="Client节点（只协调节点）"></a>Client节点（只协调节点）</h2><p>如果一个节点既不是Master也不是Data，那么这种节点就称作Client节点，也称作只协调节点。Client节点没有Master和Data节点的功能，不能存储数据，只能起到协调功能，作为ES集群内部的负载均衡器。</p>
<p>使用Client节点可以为Master节点和Data节点节省掉很多协调工作的压力。最明显的就是搜索时，需要先分散到多个节点搜索，再回到协调节点将结果进行聚合。但是过多地增加协调节点也会有浪费资源和增加选举复杂度等问题，大部分情况下，使用Data节点作为协调节点就可以很好地完成任务了。</p>
<h2 id="Ingest节点"><a href="#Ingest节点" class="headerlink" title="Ingest节点"></a>Ingest节点</h2><p>Ingest nodes can execute pre-processing pipelines, composed of one or more ingest processors. Depending on the type of operations performed by the ingest processors and the required resources, it may make sense to have dedicated ingest nodes, that will only perform this specific task.</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/27/antipattern-bikeshedding/" itemprop="url">
                  项目开发中的反模式（二）轻重倒置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-04-27T21:26:41+08:00" content="2019-04-27">
              2019-04-27
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/26/antipattern-death-march/" itemprop="url">
                  项目开发中的反模式（一）死亡行军
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-04-26T21:26:41+08:00" content="2019-04-26">
              2019-04-26
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这一系列文章主要来谈一谈，在项目开发过程中遇到的各种各样的反模式。这些反模式，不一定是指的是应用开发中的某些技术，而是包括了从项目管理到团队激励各个方面的问题。其实很多时候，决定一个项目是否能够成功的最重要因素，甚至并不是技术实力，而是这些更加宏观上的管理与决策的问题。</p>
<h2 id="什么是「死亡行军」"><a href="#什么是「死亡行军」" class="headerlink" title="什么是「死亡行军」"></a>什么是「死亡行军」</h2><p>死亡行军，英文叫做death marching。指的是在一个项目的开发过程中，所有人都不相信能够完成最后的任务，士气低落。但又没有一个人能站出来停掉这个项目，还是要继续坚持。这种项目往往伴随着大量的加班，大量的bug与修复，大量的赶工与重做。参与者会被项目折磨地疲惫不堪，最终往往以项目失败，骨干成员离职为结局。</p>
<p>再来看看维基上对「死亡行军」这个词定义</p>
<blockquote>
<p>In project management, a death march is a project that the participants feel is destined to fail, or that requires a stretch of unsustainable overwork. The general feel of the project reflects that of an actual death march because project members are forced to continue the project by their superiors against their better judgment. </p>
</blockquote>
<p>参与者根据自己的判断，都相信项目必将失败，却必须投入巨大的精力和资源，而这些仅仅是因为管理者的判断不容更改。这种项目，给团队成员带来的，不仅是时间的浪费、机会的丧失，更多的是对整个团队和管理者的不信任。</p>
<h2 id="我所经历过的死亡行军项目"><a href="#我所经历过的死亡行军项目" class="headerlink" title="我所经历过的死亡行军项目"></a>我所经历过的死亡行军项目</h2><p>我个人在职业生涯中，目前经历过三个死亡行军项目（囧），第一个更多的是作为旁观者，而后两个则参与了一些边缘的开发过程，体会颇深。</p>
<h3 id="项目一：过度复杂的产品设计"><a href="#项目一：过度复杂的产品设计" class="headerlink" title="项目一：过度复杂的产品设计"></a>项目一：过度复杂的产品设计</h3><p>第一个要说的项目是一个工具类的移动App。这个App在发布两年后，失去了用户的增长点，进入停滞状态。产品经理们苦思冥想，最终提出了一个新的功能模块，这个模块的主要功能是统合用户的一些账号和登录状态，具体就不细说了。这个产品方案提出之后，很快就进入了死亡行军的开发模式。产品的设计实在是太过复杂了！在一个App内，有着各种各样的账号状态，要登陆要注销，账号与账号之间又有着复杂的关联关系。App的安卓和IOS两端有着非常多的复杂页面和交互逻辑，移动</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/04/18/elasticsearch-update/" itemprop="url">
                  ES进阶功能 - 使用脚本更新
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-04-18T23:03:40+08:00" content="2019-04-18">
              2019-04-18
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在使用ES时，一个经常出现的操作模式就是，从ES中读取某些数据，根据本地内容进行更新，随后再重新索引到ES集群中。这么一个简单而常见的操作，实际使用过程中，如果深究的话，问题非常的多。特别是与传统的关系数据库不同，ES的数据模型并非简单的行式3NF设计，可以包含嵌套的对象，可以包含数组，甚至字段本身都可以随时增加。</p>
<h2 id="潜在的问题"><a href="#潜在的问题" class="headerlink" title="潜在的问题"></a>潜在的问题</h2><h3 id="多出的操作损耗"><a href="#多出的操作损耗" class="headerlink" title="多出的操作损耗"></a>多出的操作损耗</h3><p>首先，最直观的问题是，这样的操作会多耗费一次操作。必须先将数据拉到本地，然后才能更新回ES。一般情况下，get操作和index操作本身都比较廉价，即使是在高QPS下，实际多出的性能损耗也并不大。然而，当ES中文档对象极为复杂或庞大时，多出操作的性能损耗就不容小觑了。</p>
<p>比如当一个array字段，有成百上千的元素后，需要增加一个新元素，这时get和index两步操作都需要将全量的数据下载或上传，而实际增加的数据量却非常少。不仅多了一次网络IO，也会影响ES集群和应用自身集群的吞吐量。此外，如果自己应用中使用了ORM工具来处理ES文档，那么大对象的频繁序列化和反序列化所引起的性能损耗也是非常巨大的。在极端情况下，如果单个文档过大，甚至可能引发OOM问题。</p>
<p>当然我们还要先考虑另一个问题，当一个ES文档有过长的array或过度复杂的嵌套object时，这种数据设计是否还合理？如果使用类似关系数据库的设计方式，当然可以规避这种情况，但这时也丧失了ES自身的很多独特性能优势，使得代码过度复杂化。而且，即使大部分文档的大小都控制在可接受范围内，在业务的发展过程中，也很难避免出现个别巨型对象。是否值得为了这些个别的巨型对象而修改代码或增加专门的处理方式，也是需要根据情况来看的。也因此，我们有必要事先考虑如何应对对象较复杂的情况。</p>
<p>总结下：</p>
<ol>
<li>多一次IO</li>
<li>每次IO，应用和ES两方的性能损耗</li>
<li>序列化和反序列化，以及ORM的损耗</li>
</ol>
<h3 id="多个更新的竞争"><a href="#多个更新的竞争" class="headerlink" title="多个更新的竞争"></a>多个更新的竞争</h3><p>在多个请求更新同一个文档时，不可避免地会遇到race condition的问题。ES中并没有天生的事务支持，要想保持更新操作的一致性和原子性，无非是悲观和乐观两种方案，即分布式锁或版本控制。</p>
<p>使用分布式锁时，必然要考虑在哪里加锁。如果只对更新操作加锁，基本上是起不到同步作用的，因为读取-更新操作并非原子性的。而如果对一次读取和更新全部加锁，很容易降低读取操作的吞吐量，无法并发地处理更新。</p>
<p>另一个方案就是使用ES自带的版本控制，在更新时指定版本，ES集群发现版本不一致，则更新失败。这种做法虽然保证了一致性，但是问题是如何处理失败的情况。失败后，之前读取获得的旧操作已经失效，只能重新读取新版本的数据再重新更新。如果操作的数据并非热点数据，这种偶尔出现的重试操作效率是很高的，很好地解决了问题。但是如果操作的数据为热点数据，面临高并发的竞争，反复的重复读取-更新操作效率会急剧恶化，特别是在文档复杂的情况下。</p>
<h2 id="使用Update-Script-API"><a href="#使用Update-Script-API" class="headerlink" title="使用Update+Script API"></a>使用Update+Script API</h2><p>ES提供了Update API，以及强大的Script机制，让我们能够更好地处理文档更新的情况。使用的方法很简单，提供一个要操作的文档ID，然后用在json中提供脚本和脚本的参数即可。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST test/_<span class="keyword">update</span>/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"script"</span> : &#123;</span><br><span class="line">        <span class="string">"source"</span>: <span class="string">"ctx._source.counter += params.count"</span>,</span><br><span class="line">        <span class="string">"lang"</span>: <span class="string">"painless"</span>,</span><br><span class="line">        <span class="string">"params"</span> : &#123;</span><br><span class="line">            <span class="string">"count"</span> : <span class="number">4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如上面的例子，<code>source</code>字段中提供了脚本的代码内容，<code>lang</code>字段指定了脚本使用的语言<code>painless</code>（也是ES的默认语言），而<code>params</code>提供了脚本的参数Map（主要是为了脚本的服用）。上面的脚本语言，看起来有些让人望而却步，实际上非常简单，完全不用害怕。<code>painless</code>语言是一种类似<code>Java</code>的脚本语言。有多类似呢？写脚本代码时，就当是在写<code>Java</code>就好了，基本可以随心所欲地使用JDK中的API。所以ES的脚本编写可以说是非常轻松和简单，并不需要去学一门新的脚本语言（比如Lua).</p>
<p>配合脚本，我们可以很轻松地实现array类型数据的append操作<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ctx</span><span class="class">._source</span><span class="class">.tags</span><span class="class">.add</span>(<span class="tag">params</span><span class="class">.tag</span>)</span><br></pre></td></tr></table></figure></p>
<p>还加上判空和数组的新建操作<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx._source.tags == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ctx._source.tags = <span class="keyword">new</span> String[]&#123;<span class="keyword">params</span>.tag&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx._source.tags.add(<span class="keyword">params</span>.tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再加上类似Set的去重操作<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ctx._source.tags == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ctx._source.tags = <span class="keyword">new</span> String[]&#123;<span class="keyword">params</span>.tag&#125;;</span><br><span class="line">&#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span>(<span class="params">ctx._source.tags.contains(<span class="keyword">params</span>.tag</span>)) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果tags中已经包含新元素，不做任何操作</span></span><br><span class="line">    ctx.op = <span class="string">"noop"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ctx._source.tags.add(<span class="keyword">params</span>.tag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>需要额外注意的是，默认情况下，只要使用了Script进行Update操作，文档的版本号version就会+1，即使文档内容完全没有变化。很多情况下，我们是不需要真的去更新文档的（比如已存在元素），这时只需要调用<code>ctx.op = &quot;noop&quot;;</code>，就可以告诉ES不进行更新操作，文档的版本号也不会变化。</p>
</blockquote>
<p>此外，ES的脚本可以分为两种：<code>inlined</code>和<code>stored</code>，前者是每次请求写上去的代码，而后者是存储在ES中，请求时只需要调用脚本ID即可。详情请看官方文档。</p>
<h2 id="使用脚本的优点和缺点"><a href="#使用脚本的优点和缺点" class="headerlink" title="使用脚本的优点和缺点"></a>使用脚本的优点和缺点</h2><p>通过使用更新脚本，我们就可以将两步的读取-更新操作，合并成一次的更新脚本。如果善加利用脚本中的<code>Upsert</code>功能，我们甚至可以将插入-读取-更新，三步的操作合并成一次Update调用。使用脚本自然而然地解决了我们刚刚提出的第一个问题，大幅地减轻了多次往返所造成的大量开销。同时即使ES中出现了巨型文档，也不会直接对应用集群的性能造成影响。</p>
<p>而面对竞争问题，仅仅使用脚本更新并不能解决race condition的问题，因为在ES内部并没有对脚本的执行进行同步。即使脚本内部看上去是原子性的，实际上仍然可能将脚本更新到一个旧版本的文档上。然而，即使如此，合并成一次的Update操作也大大简化了同步问题的复杂性，我们只需要给Update操作带上版本号，利用乐观的版本控制，就可以轻松地保证脚本不执行在中间状态中。而且在高度竞争的环境下，Update脚本本身的体量也非常小，也避免了大量重试带来的性能开销和程序复杂度。</p>
<p>当然，ES脚本也并不是没有缺点的。类似SQL中逐渐被废弃的存储过程，ES脚本也有着很多存储过程所具有的问题。比如脚本更新非常难以调试，因为代码被写到了请求代码中，就很难以对脚本本身进行完备的测试。脚本代码的可读性往往也比直接的应用代码要差一些。另外，使用脚本会将很多计算逻辑从应用集群转移到ES集群，虽然节省了很多IO开销，但很有可能会增加ES的CPU负担，这点需要大量的实践测试，才能真正放心使用。而且在使用<code>stored</code>型脚本时，会给ES集群增加一个脚本ID的状态，在迁移数据、重建集群时，一定要记得迁移这个新增的状态量，否则所有使用该脚本的操作都会失效。最后，使用ES独有的脚本功能也给数据迁移到其他数据库带来了难度，使用应用和ES更加高度耦合，不过这一点其实不必过度考虑，使用ES时设计的数据模型，本就应该和其他数据库有所不同。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/28/elasticsearch-minimum/" itemprop="url">
                  Elasticsearch搜索中实现At-least-N规则，暨记录一次诡异的问题排查
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-03-28T23:25:52+08:00" content="2019-03-28">
              2019-03-28
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Elasticsearch素来以其强大的搜索能力闻名，然而，对其搜索DSL，我们用户可以说是又爱又恨。Elasticsearch的搜索基本是使用JSON构成，再配上少量HTTP内的参数。ES的搜索，可以说是成也JSON，败也JSON。所谓成，成在JSON语义强大，可以组合出各种各样的复杂请求，且歧义较少，对计算机友好；而所谓败，败在JSON并不算一个对人非常友好的格式，特别是当搜索条件比较复杂时，搜索字段又比较多，或字段长度比较长时，长长的JSON对人来说，并不容易debug或排查问题，甚至有时不那么容易看懂。</p>
<p>闲话少叙，本文要说的正题，是在搜索中实现「至少匹配N项」的方法，这个问题，对熟练使用ES的人来说很简单，对新手来说，可能有点无从下手。我们首先从最基本的情况说起，最少匹配0项或1项。</p>
<h2 id="Should的语义"><a href="#Should的语义" class="headerlink" title="Should的语义"></a>Should的语义</h2><p>ES中最奇怪也最常用的关键字应该就是这个<code>should</code>了吧。should的含义是，有must或filter的情况下，should仅仅影响结果的打分情况；而在没有must和filter的情况下，返回的结果需要至少满足一个should条件。类似布尔的OR操作，should在两种情况下分别表达出了，「可以不命中」及「至少一个命中」两种语义。</p>
<p>需要特别注意的是，当查询语句中有must或filter时，如果还想实现至少一次should命中的语义，可以使用嵌套的bool查询，或者下面要写到的<code>minimum_should_match</code>实现。</p>
<h2 id="minimum-should-match"><a href="#minimum-should-match" class="headerlink" title="minimum_should_match"></a>minimum_should_match</h2><p>上面普通的should，只是实现了N&lt;=1的情况，如果要实现更复杂的At-least-N查询，就需要使用ES中「鲜有问津」（后文会解释为什么这么说）的<code>minimum_should_match</code>参数了。</p>
<p>如下面的例子（来自官网）<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET /my_index/my_type/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"query"</span>: &#123;</span><br><span class="line">    <span class="string">"bool"</span>: &#123;</span><br><span class="line">      <span class="string">"should"</span>: [</span><br><span class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"brown"</span> &#125;&#125;,</span><br><span class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"fox"</span>   &#125;&#125;,</span><br><span class="line">        &#123; <span class="string">"match"</span>: &#123; <span class="string">"title"</span>: <span class="string">"dog"</span>   &#125;&#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"minimum_should_match"</span>: <span class="number">2</span> </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只要加入了这个参数，就可以指定搜索的结果，必须至少命中N个should语句。同时不仅支持整数，还支持百分比等形式。这一参数在一些算法中非常实用，比如在聚类算法中，往往会要求至少N个字段相同才能聚类；在搜索引擎中，也可以用这个功能来排除低相关的搜索结果。</p>
<h2 id="一次漫长的问题排查"><a href="#一次漫长的问题排查" class="headerlink" title="一次漫长的问题排查"></a>一次漫长的问题排查</h2><p>从上面的描述也可以看到，<code>minimum_should_match</code>这个参数还是比较好用的。然而在最近的一次开发中，也是在一个比较复杂的搜索请求，用到了这个参数，用来实现至少命中2个字段，以过滤大部分候选。开始并没有注意，到测试阶段的时候才发现，ES集群返回的搜索结果中，存在一些只命中了1个字段，甚至没有命中任何字段的结果！但又因为搜索中也包含了正确结果（命中2个以上字段），所以这些错误的结果很难被发现，除非提前意识到可能有问题，加上校验函数。</p>
<h3 id="Query语句写错了吗？"><a href="#Query语句写错了吗？" class="headerlink" title="Query语句写错了吗？"></a>Query语句写错了吗？</h3><p>首先怀疑的，就是JSON写错了。然而虽然用的JSON很复杂，使用<code>minimum_should_match</code>的部分还是比较简单和标准的。考虑到嵌套Bool的问题，尝试改了几版JSON，集群返回的搜索结果都完全相同。后来又试了最简单的用例，居然这个参数还是不生效！</p>
<h3 id="Mapping有问题？"><a href="#Mapping有问题？" class="headerlink" title="Mapping有问题？"></a>Mapping有问题？</h3><p>接下来怀疑的就是，索引的Mapping设置有问题，也有人提出，是不是动态模板有问题，在索引时没有将字段正确地索引进去？经过检查，所有mapping都是正确的，字段的类型也没有问题（keyword或text都正确设置了），动态模板也没有问题。</p>
<h3 id="Query和当前ES版本不兼容？"><a href="#Query和当前ES版本不兼容？" class="headerlink" title="Query和当前ES版本不兼容？"></a>Query和当前ES版本不兼容？</h3><p>我们使用的是6.2.3版本，为了确认这一问题，我又特地翻了一遍6.2.3的ES官方文档，没有发现用法错误。随后又在另一个5.X版本ES集群中测试了同样的语句，发现<code>minimum_should_match</code>完全正常工作。这就奇怪了，难道ES升级到6.x后废弃了这一功能？随后又找了6.x版本的升级说明，特别是”breaking changes”的列表，也没有找到任何说明。</p>
<h3 id="explain-true"><a href="#explain-true" class="headerlink" title="explain:true"></a>explain:true</h3><p>接下来想到了，看一看ES到底是如何解释查询语句。加上<code>explain:true</code>的语句后，ES在正常处理搜索之外，返回了解释语句的JSON，查看返回结果，果然没有任何<code>minimum_should_match</code>存在的痕迹。难道是ES集群有问题？</p>
<h3 id="定位问题"><a href="#定位问题" class="headerlink" title="定位问题"></a>定位问题</h3><p>逻辑上查不出来任何问题，可是实际上在6.2.3版本的ES集群上，简单的<code>minimum_should_match</code>就是不工作，实在是非常费解。最后笔者尝试了安装ES官方的6.2.3包到自己的机器上，部署，创建索引，写入数据。万事俱备之后，用同样的语句进行搜索，Work！同样的6.2.3版本，同样的搜索，在本机上正常工作，在集群上却失效。</p>
<p>最终笔者联系了ES集群提供方，对方团队也进行了长时间的排查。最后发现，原来该团队提供的ES版本，由他们进行了特殊的定制，定制后的ES集群会在处理搜索请求时，先对ES的查询进行「优化」，而这一优化，就将这个参数彻底丢失掉了。这一bug直接影响了ES的最基本功能，可以说是影响恶劣，类比到SQL中，就好像丢掉了一个HAVING参数一样，不可容忍。然而这一版本的定制ES，居然已经提供给许多团队使用，并且线上运行超过一年以上。如此情况下，竟然无一人发现这个重大bug，所以笔者之前说，<code>minimum_should_match</code>这个参数，或许是「鲜有问津」。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/22/elasticsearch-batch/" itemprop="url">
                  TB级别Elasticsearch的存储优化经验（三) 批处理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-03-22T21:07:32+08:00" content="2019-03-22">
              2019-03-22
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前面谈了一些使用ES过程中，存储、设计等ES本身的设计经验。今天我们来看一看在使用客户端时，有什么优化方法，可以减轻对ES的损耗。</p>
<h2 id="线性增长的调用量，非线性增长的压力"><a href="#线性增长的调用量，非线性增长的压力" class="headerlink" title="线性增长的调用量，非线性增长的压力"></a>线性增长的调用量，非线性增长的压力</h2><p>一般情况下，调用关系数据库也好，NoSQL也好，大家往往习惯按照业务逻辑编写程序，入口处每进来一个请求，后续就执行一或几次数据库CRUD操作。这是一个非常直观的选择，代码也清晰移动，但问题是，这种最简单的使用场景下，后续数据库操作的数量是和入口的请求量线性正比的。假设每个请求要进行N次CRUD操作，入口的QPS为Q，那么对数据库的调用量就是简单的N*Q。</p>
<p>当QPS较低时，N*Q的数值较小，自然不成问题。可当我们要处理的QPS是上万甚至上十万时，每次就有数十万次CRUD。应用本身抗住几万几十万的QPS并不是难事，只要合理编程，增加机器就很容易做到。但是对数据库而言，就不是那么容易了。应用本身通常是无状态的，而数据库却经常需要各个机器节点相互同步，这一复杂度远超应用，再加上数据库应用往往有较大的IO相关损耗，所以在调用量线性增长的情况下，数据库面临的压力远超线性增长的水平，是非线性的。况且像ES这样的存储，经常需要使用SSD等高成本硬件，简单地增加机器节点，并不是好的解决方法。</p>
<h2 id="ES的批量操作"><a href="#ES的批量操作" class="headerlink" title="ES的批量操作"></a>ES的批量操作</h2><p>既然QPS高了之后，数据库难以应对，那么唯一的办法就是想办法减少QPS。批处理就是一个减少QPS的办法。幸运的是，ES主要的API，都提供了对应版本的批量处理API。</p>
<ul>
<li>bulk - 批量写操作，可以混合插入、更新、删除操作</li>
<li>mget - 批量读操作</li>
<li>msearch - 批量搜索操作</li>
</ul>
<p>而且，ES对批量操作的设计是比较完善的。批量操作中，每个子项都可以设置自己的Routing，以及一些定制化的参数，互不干扰。使用这些批量API，我们可以将几十次，甚至是几千次单独的调用，合并成单一批量的读操作、写操作或搜索操作。</p>
<h2 id="批量操作的优点"><a href="#批量操作的优点" class="headerlink" title="批量操作的优点"></a>批量操作的优点</h2><p>合并成为批量操作意味着</p>
<ul>
<li>减少IO次数</li>
<li>减少成百上千次IO解析的损耗</li>
<li>大幅减少IO失败可能和重试次数</li>
<li>ES内部也可以减少大量冗余操作</li>
<li>合并大量的单独写操作，对写性能消耗大的ES来说，大幅减轻了负担</li>
</ul>
<p>使用批量处理，我们可以将数万QPS降低到数十QPS，同时每次请求携带的payload的大小，则乘以百倍或千倍。而ES处理大体量批量请求的RT，往往不会比单次请求上升太多。所以，通过批量处理的缩放，整个ES的工作效率可以大幅提升。</p>
<p>另外，批量操作还可以进行跨索引批量，能够进一步减少IO次数。</p>
<h2 id="批量操作的缺点"><a href="#批量操作的缺点" class="headerlink" title="批量操作的缺点"></a>批量操作的缺点</h2><p>当然，如果处处都使用批量操作，也存在一些缺点和问题，不得不注意</p>
<ul>
<li>构建批量请求难度较大，需要自己设计缓冲方式</li>
<li>解析批量请求的结果也更复杂，往往会出现多层嵌套</li>
<li>整体的业务代码逻辑更加复杂，相比单项请求，非常不直观，难以debug，特别是跨索引的批量</li>
<li>批量请求操作的日志的体量也会过大，无可读性，需要手动处理</li>
<li>批量请求中出现错误或异常，很容易被忽略掉</li>
<li>使用批量操作，虽然整体提高了效率，但必然会增加单个请求的RT</li>
<li>不合理的批量请求设计，同样会增加ES集群的负担</li>
</ul>
<h2 id="批量操作不是万能药"><a href="#批量操作不是万能药" class="headerlink" title="批量操作不是万能药"></a>批量操作不是万能药</h2><p>还需要提醒的一点是，虽然批量操作能够大幅提升ES的工作效率，减少大量不必要的损耗，但是，批量操作同样不是万能的。如果批量操作中所含的操作本身就非常复杂，特别是复杂的搜索操作，那么即使缓冲批量后，也不能真正意义上提升ES集群的性能瓶颈。因为在这种情况下，真正的性能瓶颈不是IO，不是卸载请求，不是搜索语句的parsing，而是搜索本身的高复杂度。如果每条搜索本身需要占用大量内存进行操作，过度批量，并不会帮助解决任何问题，反而有增大ES集群压力的风险。</p>
<p>根据自己的经验总结下，ES各种批量操作的性能提升层次大概是</p>
<blockquote>
<p>bulk &gt;&gt; mget(with routing) &gt;&gt; mget(without routing) &gt;&gt; msearch</p>
</blockquote>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前面提到，使用ES的批量操作，必然设计业务代码的改造，要在调用ES之前引入缓冲机制，那么去实现缓冲机制更好呢？这个问题虽然不大，但也比较有趣，我们下篇再提。</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/18/elasticsearch-ID/" itemprop="url">
                  TB级别Elasticsearch的存储优化经验（二）如何选择ID
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-03-18T23:11:35+08:00" content="2019-03-18">
              2019-03-18
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在传统的关系数据库中，ID字段的选择已经是老生常谈了。事实上，有些公司的开发标准上，甚至要求任何字段都选择自增主键。在ES索引设计中，ID字段的选择问题经常被开发人员所忽略，只是简单选择一个自然的ID字段。而实际上，ID的选择对索引的性能（尤其是写入性能），存在这至关重要的影响。</p>
<h2 id="四种ID选择方式"><a href="#四种ID选择方式" class="headerlink" title="四种ID选择方式"></a>四种ID选择方式</h2><p>在ES中，总体而言，存在四种ID的选择方式</p>
<ol>
<li>自然ID</li>
<li>不指定ID，由ES自动生成</li>
<li>自己指定一个UUID</li>
<li>使用文档内容的哈希值</li>
</ol>
<p>下面我们依次来看几种选择方式</p>
<h3 id="自然ID"><a href="#自然ID" class="headerlink" title="自然ID"></a>自然ID</h3><p>对可以找出自然ID的业务来说，使用自然ID是最简单的方式。但是，使用自然ID并不是完美的，也有自身的缺陷。</p>
<ol>
<li>ES无法确定你所提供的自然ID，是否真的是独一无二的，因此，每次插入时，都需要先检查有没有相同ID的文档。如果有相同ID，需要根据操作类型进行更新或者抛出异常；如果没有，才能进行插入。所以这一步检查的过程，会额外增加写入文档的RT，并增大集群的负载。</li>
<li>自然ID大多情况下是无序和随机的。ES在插入文档时，如果插入的文档ID有自增顺序，可以大幅提升插入速度，因为减少了搜索ID是否重复的时间。</li>
</ol>
<h3 id="指定UUID"><a href="#指定UUID" class="headerlink" title="指定UUID"></a>指定UUID</h3><p>UUID基本上能够保证每次生成的ID都是唯一的。使用UUID也是相对简单的一种方式。在复杂系统中，相比使用自动生成ID，使用UUID主要优势是，<strong>可以在写入ES前，先生成ID</strong>。比如，在某些需要并发多处写入的系统中，可能无法接受ES写入的RT及失败。在这种情况下，就无法使用ES自动生成的ID（因为需要等待ES返回），使用UUID就可以提前生成业务ID，并发写入多个存储系统中。</p>
<p>但是使用UUID也有很多缺陷，笔者维护的一个历史索引中，就使用了UUID，因此对其缺陷还是比较了解的。</p>
<ol>
<li>UUID是完全无意义的字符串。UUID没有意义，仅仅提供了唯一性，却没能提供任何与文档本身相关的信息量。在数据迁移和重构时，UUID本身就成为了一个负担，必须要维护UUID和文档（甚至其他索引的文档）的正确关联性，却又缺少可验证的手段（比如有时可能错误写入文档ID，这种情况下无法恢复出正确的ID，而下面介绍的哈希值则可以）。</li>
<li>插入UUID相比自动生成ID性能要差。UUID和ES自动生成ID所代表的意义基本是完全相同的（都是无意义的唯一ID），但前面已经说过，手动生成UUID获得了提前生成ID的机会，却牺牲了绕过ES写入检查的机会，会损失一些性能。</li>
</ol>
<h3 id="使用哈希值"><a href="#使用哈希值" class="headerlink" title="使用哈希值"></a>使用哈希值</h3><p>在没有自然ID的情况下，另一种选择是使用哈希函数，根据文档的内容生成一个哈希值。使用哈希，只要文档的内容相同，就会生成同样的哈希值。但使用哈希不可避免的一个问题，就是哈希碰撞。使用更长的哈希（比如MD5，SHA1），可以平衡哈希码长度和碰撞几率。如果要求更高，可以使用SHA256.</p>
<p>使用复杂哈希算法来生成ID，增加了计算的消耗，增长了ID的长度，同时也牺牲了严格的唯一性。那么为什么还要使用哈希算法呢？</p>
<ol>
<li>使用哈希可以用文档内容反推ID。特别是对计算形式的应用，ID可以在任何阶段由文档内容反推，非常灵活。</li>
<li>可以利用哈希值，高效排除重复文档。在没有自然主键的情况下，不管是使用UUID还是使用ES自动生成ID，都很容易重复写入完全相同的文档（或者仅仅时间不同的文档）。因为在写入时，没有能力判别过去是否有相同的文档（唯一的方法是搜索全部字段，但显然对性能的消耗过大），使用哈希作ID，就可以很容易避免重复写入多份相同文档。</li>
<li>可以使用文档内容，校验文档ID的正确性。这一条特别是在数据迁移，或者reindex过程中非常重要。以笔者的开发经验，不论是现在开源的几个迁移工具，还是自己使用scroll API编写的，都很容易出现bug，造成迁移后，文档ID变更，或者文档内容错乱。这个时候，使用哈希值就可以很容易地发现错误，避免迁移后默默出现错误，藏在数据库中。另外日常也可以使用哈希值来排除意外写入的脏数据。</li>
</ol>
<h4 id="使用时间戳-哈希，构造高效ID"><a href="#使用时间戳-哈希，构造高效ID" class="headerlink" title="使用时间戳+哈希，构造高效ID"></a>使用时间戳+哈希，构造高效ID</h4><p>前面提到，如果写入的文档ID，总是遵从一定的顺序，ES就可以大大增快其写入速度。但不论是自然ID也好，UUID或哈希值也好，很少能按照写入的顺序排序。要实现按照写入顺序排序，最简单的就是利用「时间」，因为时间总是在增加的。</p>
<p>使用时间戳作为ID的前缀，就可以让陆续写入的文档，满足ID的顺序性。此外，使用时间戳+哈希，还有额外的好处，就是可以极大地减少哈希碰撞的几率。因为只需要每个时间戳范围内，所有哈希值唯一，就可以唯一定位一个文档了。这样就可以使用更短和更简单的哈希算法了，也不用担心碰撞了。其缺点是，牺牲了使用哈希值判重的便利。</p>
<h3 id="ES自动生成ID"><a href="#ES自动生成ID" class="headerlink" title="ES自动生成ID"></a>ES自动生成ID</h3><p>由ES自动在插入时自动生成ID，其最大的好处是：ES知道生成的ID不可能在索引中已经存在，可以做出一些优化。<strong>使用ES自动生成的ID，是写入性能最高的选项</strong>，因为不需要检查是否重复，即使索引不断增长，其性能也不会恶化（相反，使用自己指定的ID，写入性能会随数据量上涨而恶化）。因此，在允许的情况下，使用自动生成ID往往是最好的选择。</p>
<p>当然，使用ES自动生成ID，也会有前面几种方式中提到的一些缺陷</p>
<ol>
<li>文档ID无意义，且自动生成的ID更容易混淆</li>
<li>必须先执行写入操作，写入成功后才能拿到ID</li>
</ol>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2019/03/17/elasticsearch-optimization/" itemprop="url">
                  TB级别Elasticsearch的存储优化经验（一）Routing
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2019-03-17T20:42:21+08:00" content="2019-03-17">
              2019-03-17
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>近年来，ES无疑是IR和NoSQL领域中最闪耀的一颗新星。其海量数据存储能力，复杂搜索能力，和准实时读写能力，填补了许多传统关系数据库能力上的空缺。然而，任何技术都有其trade-off，并不存在一颗「银色子弹」，可以在没有任何牺牲的情况下，满足人们对数据库的所有要求。在使用ES时，如果不经设计，简单地进行数据写入和搜索，在读写流量低、文档数目少时，仍能满足需求。一旦流量走大，文档数随时间积累越来越多，ES的整体性能和读写RT，将出现剧烈地下降，甚至整个集群进入瘫痪状态。下面就根据笔者存储50亿ES文档的经验，简单介绍几个优化方案。首先第一篇，使用Routing写入和搜索。</p>
<h2 id="使用Routing写入和搜索"><a href="#使用Routing写入和搜索" class="headerlink" title="使用Routing写入和搜索"></a>使用Routing写入和搜索</h2><p>选择ES进行数据存储，往往最看重其强大的搜索能力。然而必须指出，虽然ES可以支持极其复杂的搜索条件，但是，随着搜索复杂度和总文档数的增加，其搜索性能也会不断恶化。究其原因，搜索的操作往往需要查询所有节点，找到所有可能命中后，再进行merge操作。大量的搜索操作，频繁而重复地查询集群中所有节点，容易导致整个集群的load飙升。</p>
<p>ES提供了一个强大的功能，即Routing。Routing是在写入时，提供一个Routing值，根据这个值的哈希值，路由写入到ES中的某个shard中。而在搜索中，如果同样带上Routing值，便可根据哈希值进行路由，最终仅仅搜索路由到的单个shard。这样可以大大减轻其他shard的工作量。在实际开发中，集群可支撑的带Routing搜索的QPS，往往超过非Routing搜索的百倍。而带Routing搜索的RT，也比非Routing会大大降低。</p>
<p>在没有提供Routing时，ES会默认使用文档ID作为Routing。Routing归根结底是为了搜索流量服务，因此指定Routing字段时，应该首先考虑最常发生的搜索方式。如在存储「文章」的索引中，可以以「作者ID」作为routing，这样就可以快速搜到某个作者的所有文章了。</p>
<p>还有一个需要指出的问题是，集群一旦开始写入数据，routing便无法有效地更改。因此，在最初设计时，一定要计划好如何做routing，否则只能对数据进行reindex，重新构建索引。</p>
<p>另外还需要注意的是，使用Routing后，ID的唯一性就只在shard内保证，不再检查整个索引内的唯一性。</p>
<blockquote>
<p>When indexing documents specifying a custom _routing, the uniqueness of the _id is not guaranteed across all of the shards in the index. In fact, documents with the same _id might end up on different shards if indexed with different _routing values.</p>
</blockquote>
<p>It is up to the user to ensure that IDs are unique across the index.</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/11/15/levelDB-as-persistence/" itemprop="url">
                  不要用持久化缓存代替底层数据库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2018-11-15T22:32:27+08:00" content="2018-11-15">
              2018-11-15
            </time>
          </span>

          

          
            
          

          

          
          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近接手了一个老项目，这个项目的主要功能是通过一系列计算，算出输入对象的某个特征信息。也就是说，计算的结果是简单的K-V形式。而大量的计算结果，都需要存储起来，提供给高QPS的请求访问。</p>
<p>在这一项目中，原作者是使用了LevelDB作为最终的存储引擎，多年以来，很好地支撑了数万的QPS。</p>
<h2 id="LevelDB的优势"><a href="#LevelDB的优势" class="headerlink" title="LevelDB的优势"></a>LevelDB的优势</h2><p>首先说明一下，这里说的LevelDB并非原始开源版本的LevelDB，而是内部封装改良后的分布式版本。原始的LevelDB，有一个最突出的特性，就是「写快读慢」。在写入时，只需要写入log即可返回，而读取时，往往需要读取磁盘上的LSM树。内部改良的版本，使用了SSD作为存储介质，很好地解决了读取相对较慢的问题。</p>
<p>在此基础上，原项目使用LevelDB的好处，主要是以下几点：</p>
<ol>
<li>读写速度都很快，使用SSD后，读写RT保持在0.5ms以内</li>
<li>使用简单，单纯的KV操作，开发起来也非常轻松</li>
<li>数据持久化，并且有replica存在，可保证数据容灾性</li>
<li>使用硬盘存储，可支撑大量的数据</li>
</ol>
<h2 id="简单使用LevelDB存储的隐患"><a href="#简单使用LevelDB存储的隐患" class="headerlink" title="简单使用LevelDB存储的隐患"></a>简单使用LevelDB存储的隐患</h2><p>高QPS、超低的RT、高吞吐量、所有数据持久化、容灾机制，看起来这一版本的LevelDB已经能够满足了所有的需求。然而，正是这些高性能的表现，掩盖了LevelDB不适合作为最终存储工具的原因：LevelDB并不提供数据导出接口！</p>
<p>不提供数据导出接口的数据存储，是无法扩展的，其本质上只能起到缓存的作用。当项目因为业务的变化，需要大量增加存储量或QPS时，或者需要改变存储结构时，再或者需要对数据进行离线分析时，都需要存储层支持数据的批量导出。比如ES就有scroll、reindex等等多个API可供操作，MySQL也有自己的数据导出机制。而LevelDB只支持数据的批量导入，却不能批量导出或全量扫描，这就意味着数据进行LevelDB后，就进入了死胡同，不可能再导出，必须有其他的数据源提供数据回流的支持，才能方便以后项目的扩展和重构。</p>
<h2 id="无法扩展"><a href="#无法扩展" class="headerlink" title="无法扩展"></a>无法扩展</h2><p>就拿本人所遇到的这个例子来说。原项目使用LevelDB存储了大约40亿条的KV数据，其读QPS在10万左右。现在突然有一个业务合作，业务方需要以300万的QPS读取其中的40亿条KV数据。这时怎么办呢？最简单的办法，建立新的LDB集群，查不到再查原来的LDB。这种方法乍一看可行，实际上绝大多数的流量依然会打到原来的LDB上，导致其无法承受超高的QPS挂掉。还有一种更加不靠谱的思路，手动吧，遍历全部的Key，然后一条条写入新集群。这种做法本质上还是把全量的QPS引入了旧集群，即使可行，也需要注意扫描的QPS不可过高，在面对海量数据的情况下，甚至需要几天乃至一两周的时间，才能安全完成扫描。这还并不考虑新老数据的同步与覆盖的问题。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>因此，即使LevelDB性能再好，操作再简单，即使100%契合了当下的业务需求，也必须注意，不能将LevelDB作为唯一和最终的数据持久层，否则数据将被困在LevelDB中。这一问题，在公司内部的很多项目中都有见到，LevelDB的存储性能实在是太过诱人，其各项功能也总能满足业务需求，很多团队都简单地将数据最终存进LevelDB中。这样做也并非不可以，但一定要考虑到其后果！</p>

          
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    

  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/15/">15</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel  sidebar-panel-active ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/default_avatar.jpg"
               alt="SphiaTower" />
          <p class="site-author-name" itemprop="name">SphiaTower</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">148</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>
          
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">60</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">SphiaTower</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="http://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  



  



  
  

  
  


</body>
</html>
